<?php
// $Id$

/**
 * Neologism Module
 * Allows users to easily publish their own vocabulary online
 */

define("NEOLOGISM_CT_VOCABULARY", "neo_vocabulary");
define("NEOLOGISM_CT_CLASS", "neo_class");
define("NEOLOGISM_CT_PROPERTY", "neo_property");

define("DEFAULT_RDFS_SUPERCLASS", "rdfs:Resource");

// @todo Consolidate these with the constants defined in evoc
define("DISJOINTS_WITH", "disjointwith");
define("SUPERCLASSES", "superclasses");
define("DOMAINS", "domains");
define("RANGES", "ranges");
define("SUBPROPERTYOF", "subpropertyof");
define("INVERSE", "inverse");

/**
 * Implementation of hook_init().
 */
function neologism_init() {

  // Init the custom content negotiation aware cache
  module_load_include('inc', 'neologism', 'neologism.conneg');
  _neologism_negotiated_cache_start();

  // Drupal doesn't find the preprocessing functions for the theme_node if it's
  // not explicitly loaded here
  module_load_include('inc', 'neologism', 'neologism.theme');

  drupal_add_css(drupal_get_path('module', 'neologism') .'/neologism.css');
  
  $scripts = array(
    '/js/neologism.js',
    '/js/neologism.termstree.js',
    '/js/evocfields/superclass.widgetbehaviour.js',
    '/js/evocfields/disjointwith.widgetbehaviour.js',
    '/js/evocfields/domain.widgetbehaviour.js',
    '/js/evocfields/range.widgetbehaviour.js',
    '/js/evocfields/superproperty.widgetbehaviour.js',
    '/js/evocfields/inverse.widgetbehaviour.js',
  );
  foreach ($scripts as $script) {
    drupal_add_js(drupal_get_path('module', 'neologism') . $script);
  }
}

/**
 * Implementation of hook_perm().
 */
function neologism_perm() {
  return array('edit vocabularies', 'import vocabularies');
}

/**
 * Implementation of hook_theme().
 */
function neologism_theme(&$existing) {
  return array(
    'neologism_qname' => array(
      'arguments' => array('qname' => NULL),
      'file' => 'neologism.theme.inc',
    ),
    // This makes Drupal search for node type templates in the Neologism
    // directory too; we need this for the template that displays class
    // and property nodes
    'node' => array(
      'path' => drupal_get_path('module', 'neologism'),
    ),
  );
}

/**
 * Implementation of hook_menu_alter().
 */
function neologism_menu_alter(&$items) {
  // Replace node_page_view with a custom content negotiation enabled version
  $items['node/%node']['page callback'] = 'neologism_node_page_view_with_conneg';
}

/**
 * Implementation of hook_menu().
 */
function neologism_menu() {
  $items = array();
  $items['node/%neologism_vocabulary/add-class'] = array(
      'title' => 'Add new class',
      'page callback' => 'neologism_add_term',
      'page arguments' => array(NEOLOGISM_CT_CLASS, 1),
      'access callback' => 'node_access',
      'access arguments' => array('update', 1),
      'type' => MENU_LOCAL_TASK,
      'weight' => 10,
  );
  $items['node/%neologism_vocabulary/add-property'] = array(
      'title' => 'Add new property',
      'page callback' => 'neologism_add_term',
      'page arguments' => array(NEOLOGISM_CT_PROPERTY, 1),
      'access callback' => 'node_access',
      'access arguments' => array('update', 1),
      'type' => MENU_LOCAL_TASK,
      'weight' => 11,
  );
  $items['node/%neologism_vocabulary/add-class/%node'] = array(
      'page callback' => 'neologism_add_term',
      'page arguments' => array(NEOLOGISM_CT_CLASS, 1, 3),
      'access callback' => 'node_access',
      'access arguments' => array('update', 1),
      'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['node/%neologism_vocabulary/add-property/%node'] = array(
      'page callback' => 'neologism_add_term',
      'page arguments' => array(NEOLOGISM_CT_PROPERTY, 1, 3),
      'access callback' => 'node_access',
      'access arguments' => array('update', 1),
      'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['node/%neologism_vocabulary/html'] = array(
      'page callback' => 'neologism_export_html',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['node/%neologism_vocabulary/rdf'] = array(
      'page callback' => 'neologism_export_rdfxml',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['node/%neologism_vocabulary/ttl'] = array(
      'page callback' => 'neologism_export_turtle',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['node/%neologism_vocabulary/xml'] = array(
      'page callback' => 'neologism_export_xml',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['node/%neologism_vocabulary/layout'] = array(
      'page callback' => 'neologism_diagram_layout',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['neologism/import'] = array(
    'title' => 'Import vocabulary',
    'description' => 'Import an existing RDF vocabulary from the Web or from an RDF file for editing.',
    'page callback' => 'neologism_import_form_callback',
    'access arguments' => array('import vocabularies'),
    'file' => 'neologism.import.inc',
    'weight' => 5,
  );
  // ajax/json gateway for preview classes and properties
  $items['neologism/json/classestree'] = array(
    'title' => 'Neologism AJAX gateway',
    'description' => 'Neologism Ajax Gateway.',
    'page callback' => 'neologism_gateway_get_classes_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );
  $items['neologism/json/objectpropertytree'] = array(
    'title' => 'Neologism AJAX gateway',
    'description' => 'Neologism Ajax Gateway.',
    'page callback' => 'neologism_gateway_get_properties_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );
  $items['neologism/json/fulltree'] = array(
    'title' => 'Neologism AJAX gateway - get full classes tree structure',
    'description' => 'Get full tree for all the current classes stored in Neologism.',
    'page callback' => 'neologism_gateway_get_full_classes_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );
  $items['neologism/json/propertiesfulltree'] = array(
    'title' => 'Neologism AJAX gateway - get full properties tree structure',
    'description' => 'Get get full properties tree structure stored in Neologism.',
    'page callback' => 'neologism_gateway_get_full_properties_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );
  return $items;
}

/**
 * Implementation of hook_exit().
 */
function neologism_exit() {
  // hook_exit is invoked even if the page was served from cache; it would
  // be nicer to check that condition inside _neologism_negotiated_cache_end(),  // but in the case of cache hits, Drupal is not fully bootstrapped and
  // including other code files for a module doesn't work. So we do that
  // check here.
  global $neologism_is_negotiated;
  if ($neologism_is_negotiated) {
    _neologism_negotiated_cache_end();
  }
} 

/**
 * Implementation of hook_form_alter().
 */
function neologism_form_alter(&$form, &$form_state, $form_id) {
  module_load_include('inc', 'neologism', 'neologism.nodeforms');
  if ($form_id == 'neo_vocabulary_node_form') {
    _neologism_form_alter_vocabulary($form, $form_state);
  } else if ($form_id == 'neo_property_node_form') {
    _neologism_form_alter_term($form, $form_state, 'property');
  } else if ($form_id == 'neo_class_node_form') {
    _neologism_form_alter_term($form, $form_state, 'class');
  }
}

/**
 * Implementation of hook_rdf_namespaces().
 */
function neologism_rdf_namespaces() {
  // Start with the namespaces required in Neologism's RDF output.
  // The others (rdf, rdfs, dc, owl, foaf) should already be present
  // because they were imported into evoc at installation time.
  $namespaces = array(
    'vann' => 'http://purl.org/vocab/vann/',
  );
  // Add namespaces of all user-created vocabularies
  // TODO Use the node's path instead of title when no custom namespace is defined
  $vocs = db_query(db_rewrite_sql("SELECT n.title, c.field_custom_namespace_value AS custom FROM {content_type_neo_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE n.type = '%s'"), NEOLOGISM_CT_VOCABULARY);
  while( $voc = db_fetch_object($vocs) ) {
    $namespaces[$voc->title] = $voc->custom ? $voc->custom : url($voc->title, array('absolute' => TRUE)) . '#';
  }
  return $namespaces;
}

/**
 * Implementation of hook_menu_link_alter().
 */
function neologism_menu_link_alter(&$item, $menu) {
  // Hide the Class and Property content types from the Create Content menu
  switch ($item['link_path']) {
    case 'node/add/neo-class':
    case 'node/add/neo-property':
      $item['hidden'] = 1;
      break;  
  }
}

/**
 * Implementation of hook_link_alter().
 */
function neologism_link_alter(&$links, $node) {
  // Remove the “Read more” link on vocabularies
  if ($node->type == 'neo_vocabulary') {
    unset($links['node_read_more']);
  }
}

/**
 * Implementation of hook_link().
 *
 * The “Edit class/property” and “Add subclass/property” on term nodes
 * are placed by this function.
 */
function neologism_link($type, $node = NULL, $teaser = FALSE) {
    $links = array();
    $vocabulary_nid = $node->field_vocabulary[0]['nid'];

    // Content type in urls are with - instead of _
    $vocabulary_url_str = str_replace('_', '-', NEOLOGISM_CT_VOCABULARY);
    $class_url_str = str_replace('_', '-', NEOLOGISM_CT_CLASS);
    $property_url_str = str_replace('_', '-', NEOLOGISM_CT_PROPERTY);

    //if( $type == 'node' )
	if (user_access('edit vocabularies') && $node->type == NEOLOGISM_CT_CLASS) {
      $links['neologism_edit_class'] = array(
        'title' => t('Edit'),
        'href' => "node/$node->nid/edit",
	    'attributes' => array('title' => 'Edit '.$node->field_label[0]['value'].' class.')
      );
      $links['neologism_add_subclass'] = array(
        'title' => t('Create new subclass'),
        'href' => "node/" . $node->vocabulary->nid . "/add-class/$node->nid",
      	'attributes' => array('title' => 'Create a new class as subclass of '.$node->field_label[0]['value'].'.')	
      );
    }

    if (user_access('edit vocabularies') && $node->type == NEOLOGISM_CT_PROPERTY) {
      $links['neologism_edit_property'] = array(
        'title' => t('Edit'),
        'href' => "node/$node->nid/edit",
      );
      $links['neologism_add_subproperty'] = array(
        'title' => t('Create new subproperty'),
        'href' => "node/" . $node->vocabulary->nid . "/add-property/$node->nid",
      	'attributes' => array('title' => 'Create a new property as subproperty of '.$node->field_label[0]['value'].'.')	
      );
    }

    return $links;
}

// @todo Move remaining hook implementations up here. hook_nodeapi is further down in the file


/**
 * A menu wildcard loader for the %neologism_vocabulary wildcard. It loads
 * vocabulary nodes, and causes a Not Found for any other kind of node.
 */
function &neologism_vocabulary_load($nid) {
  if (!$nid) return FALSE;
  $node = node_load($nid);
  if (!$node || $node->type != NEOLOGISM_CT_VOCABULARY) return FALSE;
  return $node;
}

/**
 * A custom version of node_page_view() that applies content negotiation to content
 * types that support it.
 *
 * @param $node
 *   The node to be viewed
 * @return
 *   HTML rendering of the node
 */
function neologism_node_page_view_with_conneg($node) {
  if ($node->type == NEOLOGISM_CT_VOCABULARY) {
    return _neologism_do_conneg($node, array(
      'html' => 'neologism_export_html',
      'rdf' => 'neologism_export_rdfxml',
      'ttl' => 'neologism_export_turtle',
    ));
  }
  return node_page_view($node);
}

/**
 * This function build the breadcrumb for neologism
 * @param $path
 * @param $title
 * @return unknown_type
 */
function _neologism_build_breadcrumb($path = null, $title = NULL) {
  $breadcrumb = array(l('Home', '<front>'));
  if ($path) {
    $breadcrumb[] = l($title ? $title : $path, $path);
  }
  return $breadcrumb;
}

/**
 * Builds the form for adding terms (classes or properties).
 *
 * @param $type
 *   'neo_class' or 'neo_property'
 * @param $vocabulary
 *   The vocabulary owning the new term
 * @param $parent_node
 *   An optional superclass or superproperty; a node of neo_class or
 *   neo_property type
 * @return
 *   A built form
 */
function neologism_add_term($type, $vocabulary, $parent_node = null) {
  global $user;
  include_once('modules/node/node.pages.inc');

  // @todo display an error message
  if (!node_access('create', $type)) return;

  // Sanity check: If a parent is specified, is it of the type we're asked to create?
  if ($parent_node && $parent_node->type != $type) return;

  // Copied from node_add
  $node = array('uid' => $user->uid, 'name' => (isset($user->name) ? $user->name : ''), 'type' => $type, 'language' => '');

  $node['vocabulary'] = $vocabulary;
  return drupal_get_form($type . '_node_form', $node);
}

/**
 * Creates an RDF representation of a vocabulary.
 *
 * @param $node
 *   A vocabulary node
 * return
 *   A NeologismRDFWriter that contains the triples
 */
function &neologism_get_rdf_model($node) {
  $required_namespaces = array($node->title, 'rdf', 'rdfs', 'dc', 'owl', 'foaf', 'vann');
  $classes = _neologism_get_all_classes($node, $required_namespaces);
  $properties = _neologism_get_all_properties($node, $required_namespaces);
  
  // Set up model with all necessary namespaces
  $namespaces = rdf_get_namespaces();
  module_load_include('inc', 'neologism', 'neologism.rdfwriter');
  $rdf = new NeologismRDFWriter();
  foreach ($required_namespaces as $prefix) {
    $ns = $namespaces[$prefix];
    if (is_array($ns)) {
      $ns = $ns[0];
    }
    $rdf->register_namespace($prefix, $ns);
  }
    
  // export the ontology
  $doc = url($node->path, array('absolute' => true));
  $rdf->triple_qname($doc, "rdf:type", 'owl:Ontology');
  $rdf->triple_literal($doc, "dc:title", $node->field_title[0]['value']);
  $rdf->triple_literal($doc, "dc:description", $node->field_abstract[0]['value']);
  $rdf->triple_literal($doc, "vann:preferredNamespaceUri", $node->namespace_uri);
  $rdf->triple_literal($doc, "vann:preferredNamespacePrefix", $node->title);
  $rdf->triple_uri($doc, "foaf:page", $doc . '.html');
  
  // authors and affiliations
  foreach ($node->field_authors as $uid) {
    if (is_null($uid['uid'])) continue;
    $author = user_load($uid);
    $person = $doc . '#' . rawurlencode($author->name);
    $rdf->triple_uri($doc, "dc:creator", $person);
    $rdf->triple_qname($person, "rdf:type", 'foaf:Person');
    if ($author->profile_neologism_fullname) {
      $rdf->triple_literal($person, "foaf:name", $author->profile_neologism_fullname);
    } else {
      $rdf->triple_literal($person, "foaf:nick", $author->name);
    }
    $rdf->triple_uri($person, "foaf:homepage", $author->profile_neologism_homepage);
    if ($author->profile_neologism_show_email) {
      $rdf->triple_uri($person, "foaf:mbox", "mailto:" . $author->mail);
    }
    if ($author->profile_neologism_affiliation) {
      $org = $doc . '#' . rawurlencode($author->profile_neologism_affiliation);
      $rdf->triple_qname($org, 'rdf:type', 'foaf:Organization');
      $rdf->triple_uri($org, 'foaf:member', $person);
      $rdf->triple_literal($org, 'foaf:name', $author->profile_neologism_affiliation);
      $rdf->triple_uri($org, 'foaf:homepage', $author->profile_neologism_affiliation_homepage);
    }
  }

  // classes
  foreach ($classes as $class) {
    $class_uri = $node->namespace_uri . $class["id"];
    $rdf->triple_qname($class_uri, "rdf:type", 'rdfs:Class');
    $rdf->triple_qname($class_uri, "rdf:type", 'owl:Class');
    $rdf->triple_uri($class_uri, "rdfs:isDefinedBy", $doc);
    $rdf->triple_literal($class_uri, "rdfs:label", $class["label"]);
    $rdf->triple_literal($class_uri, "rdfs:comment", $class["comment"]);
    $rdf->triples_qname($class_uri, "rdfs:subClassOf", $class[SUPERCLASSES]);
    $rdf->triples_qname($class_uri, "owl:disjointWith", $class[DISJOINTS_WITH]);
  }
 
  $literal_types = array();
  foreach (neologism_get_literal_datatype_list() as $types) {
    $literal_types = array_merge($literal_types, $types);
  }
  // export all properties
  foreach ($properties as $property) {
    $property_uri = $node->namespace_uri . $property["id"];
    $rdf->triple_qname($property_uri, "rdf:type", 'rdf:Property');
    // Try to determine wether it's an Object- or DatatypeProperty
    // @todo To determine owl:ObjectProperty, we have to make sure that none of the ranges are subclasses of rdf:Datatype or rdfs:Class or owl:Class
    if ($property[RANGES] && !array_diff($property[RANGES], $literal_types)) {
      $rdf->triple_qname($property_uri, 'rdf:type', 'owl:DatatypeProperty');
    }
    $rdf->triple_uri($property_uri, "rdfs:isDefinedBy", $doc);
    $rdf->triple_literal($property_uri, "rdfs:label", $property["label"]);
    $rdf->triple_literal($property_uri, "rdfs:comment", $property["comment"]);
    $rdf->triples_qname($property_uri, 'rdfs:domain', $property[DOMAINS]);
    $rdf->triples_qname($property_uri, 'rdfs:range', $property[RANGES]);
    $rdf->triples_qname($property_uri, 'rdfs:subPropertyOf', $property[SUBPROPERTYOF]);
    if (!empty($property['isInverseFunctional'])) {
      $rdf->triple_qname($property_uri, 'rdf:type', 'owl:InverseFunctionalProperty');
    }
    if (!empty($property["isFunctional"])) {
      $rdf->triple_qname($property_uri, 'rdf:type', 'owl:FunctionalProperty');
    }
    if (!empty($property[INVERSE])) {
      $rdf->triple_qname($property_uri, 'owl:inverseOf', $property['inverse']);
    }
  }
  
  if( !empty($node->field_additional_custom_rdf) ) {
  	// TODO If the vocabulary's Turtle or RDF/XML is viewed, and the custom RDF field is not empty, then the 
		// content of that field will be parsed with a Turtle parser and loaded into the model that is used to 
		// generate the Turtle or RDF/XML output. So the additional triples will show up when the model is 
		// rendered.
		// Add code to do such a thing here
  }
  
  
  return $rdf;
}

/**
 * Output the RDF/XML version of the vocabulary specified as input
 */
function neologism_export_rdfxml($node) {
    $rdf = neologism_get_rdf_model($node);
    $rdf->write_rdfxml();
}

/**
 * Output the Turtle version of the vocabulary specified as input
 */
function neologism_export_turtle($node) {
    $rdf = neologism_get_rdf_model($node);
    $rdf->write_turtle();
}

/**
 * Output the XML version of the vocabulary specified as input
 * using simpleXML
 * seeAlso http://www.php.net/simplexml
 */
function neologism_export_xml($node) {

  $xml = simplexml_load_string('<vocabulary/>');
  $xml->addAttribute('id', $node->title);

  //export all classes
  $classes = _neologism_get_all_classes($node);
  $classes_node = $xml->addChild('classes');
  foreach ( $classes as $class ) {
    $classnode = $classes_node->addChild('Class');
    $classnode->addAttribute('id', $class['id']);
    $classnode->addChild('label', $class['label']);
    
    if( isset($class['comment']) )
    {
      // we are using check_plain() for comment to avoid the 
      // warning: SimpleXMLElement::addChild() [simplexmlelement.addchild]: 
      // unterminated entity reference bytes. Being abstract, physical parts of computer 
      // memory that encode a file are excluded from the concept. 
      // in ...\sites\all\modules\neologism\neologism.module on line 714.
      $classnode->addChild('comment', check_plain($class['comment']));  
    }
    
    if( isset($class[SUPERCLASSES]) ) {
      foreach( $class[SUPERCLASSES] as $value ) {
        $subclassof_node = $classnode->addChild('subClassOf');
        $subclassof_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($class[DISJOINTS_WITH]) ) {
      foreach( $class[DISJOINTS_WITH] as $value ) {
        $disjointwith_node = $classnode->addChild('disjointWith');
        $disjointwith_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($class['description']) ) {
      $classnode->addChild('description', $class['description']);  
    }
  }

  //export all properties
  $properties = _neologism_get_all_properties($node);
  $properties_node = $xml->addChild("properties");
  foreach ($properties as $property) {
    $propertynode = $properties_node->addChild('Property');
    $propertynode->addAttribute('id', $property['id']);
    $propertynode->addChild('label', $property['label']);
    $propertynode->addChild('comment', $property['comment']);
    if( isset($property[SUBPROPERTYOF]) ) {
      foreach( $property[SUBPROPERTYOF] as $value ) {
        $subpropertyof_node = $propertynode->addChild('subPropertyOf');
        $subpropertyof_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($property[DOMAINS]) ) {
      foreach( $property[DOMAINS] as $value ) {
        $domain_node = $propertynode->addChild('domain');
        $domain_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($property[RANGES]) ) {
      foreach( $property[RANGES] as $value ) {
        $range_node = $propertynode->addChild('range');
        $range_node->addAttribute('resource', $value);
      }
    }
    
    //<rdf:type rdf:resource="http://www.w3.org/2002/07/owl#FunctionalProperty"/>
    if( !empty($property["isInverseFunctional"]) ) {
      $type_node = $propertynode->addChild('type');
      $type_node->addAttribute('resource', 'FunctionalProperty');
    }
    
    if( !empty($property["isFunctional"]) ) {
      $type_node = $propertynode->addChild('type');
      $type_node->addAttribute('resource', 'InverseFunctionalProperty');
    }
  }

  drupal_set_header("Content-Type: application/xml; charset=utf-8");
  echo $xml->asXml();
}

/**
 * Layout of the vocabulary using REST
 */
function neologism_diagram_layout($node) {
  $name = $node->title;
  if (isset($_POST['layout']) && drupal_valid_token($_POST['token'])) {
    //POST, so write layout
    $layout = $_POST['layout'];
    neologism_write_layout($node, $layout);
  } 
  else {
    //GET, so read it
    $layout = neologism_get_layout($node);
    if ($layout == NULL) {
      $layout = neologism_generate_layout($node);
    }
    
    drupal_set_header("Content-Type: application/xml; charset=utf-8");
    echo $layout;
  }
}

/**
 * Get layout of a vocabulary
 */
function neologism_get_layout($node) {
  $result = db_fetch_array(db_query("select field_layout_value from {content_type_".NEOLOGISM_CT_VOCABULARY."} where nid = %d", $node->nid));
  $layout = $result[field_layout_value];
  return $layout;
}

/**
 * Generate a random layout for this vocabulary
 */
function neologism_generate_layout($node) {
  $xml = simplexml_load_string('<layout/>');
  $classes = _neologism_get_all_classes($node);
  $y = 0;
  foreach ($classes as $oneclass) {
    //export all classes
    $y = $y + 50;
    $class = $xml->addChild("rdfclass");
    $class->addAttribute("name", $oneclass["title"]);
    $class->addAttribute("label", $oneclass["label"]);
    $class->addAttribute("x", "50");
    $class->addAttribute("y", $y);
    $class->addAttribute("width", "100");
    $class->addAttribute("height", "30");
  }
  return $xml->asXml();
}

/**
 * Write the layout of a vocabulary
 */
function neologism_write_layout($node, $layout) {
  db_query("update {content_type_".NEOLOGISM_CT_VOCABULARY."} set field_layout_value = '%s' where nid = %d", $layout, $node->nid);
  content_clear_type_cache();
}

/**
 * Read/write diagram image image
 */
function neologism_image($node) {
  $name = $node->title;
  $output = 'For the moment this feature is not available';
  return $output;
}

/**
 * Implementation of hook_nodeapi().
 */
function neologism_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {

    case 'prepare':
  		if( $node->type == NEOLOGISM_CT_CLASS ) {
  			variable_set('previous_class_title', $node->title);
      	
  			// TODO working in this commented code, tvm guidocecilio
  			/*
  			if( !isset($node->vocabulary) ) {
      		$vocabulary_nid = NULL;
  				if( arg(2) == 'edit' ) {
      			$vocabulary_nid = $node->field_vocabulary[0]['nid']; // there is different way to get this value
      		}
      		else if( arg(3) == 'parent' ) {
      			$node_class = node_load(arg(4));
      			$vocabulary_nid = $node_class->field_vocabulary[0]['nid'];
      		}
      		else if( isset($_GET['v']) ) {
      			$vocabulary_nid = (int)$_GET['v'];
      		}
      		
      		$vocabulary = node_load($vocabulary_nid);	
      	}
      	kpr($node);
      	*/
      	
      }
      else if( $node->type == NEOLOGISM_CT_PROPERTY ) {
        variable_set('previous_property_title', $node->title);
      }
 
  	  break;
  	  
    case 'load':

      // Load various read-only values for more convenient access
      if ($node->type == NEOLOGISM_CT_VOCABULARY) {

        $node->prefix = $node->title;

        $custom = $node->field_custom_namespace[0]['value'];
        $node->namespace_uri = $custom ? $custom : url($node->path, array('absolute' => TRUE)) . '#';
        $node->has_custom_namespace_uri = (boolean) $custom;

        // this is a fast solution to show the vocabulary statistic to the user
        $node->count_classes = db_result(db_query(db_rewrite_sql("SELECT COUNT(*) FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_CLASS));
        $node->count_properties = db_result(db_query(db_rewrite_sql("SELECT COUNT(*) FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_PROPERTY));

        $node->authors = array();
        foreach($node->field_authors as $author) {
          $author = user_load($author);
          $name = empty($author->profile_neologism_fullname) ? $author->name : $author->profile_neologism_fullname;
          if ($author->profile_neologism_homepage) {
            $node->authors[] = l($name, $author->profile_neologism_homepage);
          } else {
            $node->authors[] = $name;
          }
        }
      }

      if ($node->type == NEOLOGISM_CT_CLASS || $node->type == NEOLOGISM_CT_PROPERTY) {
        // Load the vocabulary of the class/property
        $node->vocabulary = node_load($node->field_vocabulary[0]['nid']);
        // Keep a copy of the body around because the original isn't accessible in themeing
        $node->original_body = $node->body;
        $node->qname = $node->vocabulary->prefix . ':' . $node->title;
      } 

      break;

    case 'update':
      if($node->type == NEOLOGISM_CT_VOCABULARY) {
        _neologism_update_aliases($node);
      }
      elseif( $node->type == NEOLOGISM_CT_CLASS ) {
        $term = array();
        
        // $node->update_by_reference is used when an update comes from other references than a normal update
        $term['previous_id'] = !isset($node->update_by_reference) ? variable_get('previous_class_title', $node->title) : $node->title;
        $term['id'] = $node->title;
        $term['type'] = 'class';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normalize the superclasses array to used by evoc's evoc_write_class() method
        $term['superclasses'] = array();
        if( !empty($node->field_superclass2) && is_array($node->field_superclass2) ) {
          foreach ( $node->field_superclass2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term['superclasses'][] = $value['evoc_term'];
            }
          }
        }
        
      	$term[EVOC_DISJOINTS] = array();
        if( !empty($node->field_disjointwith2) && is_array($node->field_disjointwith2) ) {
          foreach ( $node->field_disjointwith2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DISJOINTS][] = $value['evoc_term'];
            }
          }
        }
        
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        // update vocabulary revision
        _neologism_vocabulary_save($vocabulary);
        
        evoc_update_class($term);  
      }
      elseif( $node->type == NEOLOGISM_CT_PROPERTY ) {
      	$term = array();
        // $node->update_by_reference is used when an update comes from other references than a normal update
        $term['previous_id'] = !isset($node->update_by_reference) ? variable_get('previous_property_title', $node->title) : $node->title;
        $term['id'] = $node->title;
        $term['type'] = 'property';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normaliza the evoc's fields
        $term[EVOC_DOMAINS] = array();
        if( !empty($node->field_domain2) && is_array($node->field_domain2) ) {
          foreach ( $node->field_domain2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DOMAINS][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_RANGES] = array();
        if( !empty($node->field_range2) && is_array($node->field_range2) ) {
          foreach ( $node->field_range2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_RANGES][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_SUPERPROPERTIES] = array();
        if( !empty($node->field_superproperty2) && is_array($node->field_superproperty2) ) {
          foreach ( $node->field_superproperty2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_SUPERPROPERTIES][] = $value['evoc_term'];
            }
          }
        }
        
        //kpr($form);
      	$term[EVOC_INVERSES] = array();
        if( !empty($node->field_inverse2) && is_array($node->field_inverse2) ) {
          foreach ( $node->field_inverse2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_INVERSES][] = $value['evoc_term'];
            }
          }
        }
        
        // inverse normalizatio should goes here
        $term[EVOC_INVERSE] = $node->field_inverse2[0]['evoc_term'];
 
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        // update vocabulary revision
        _neologism_vocabulary_save($vocabulary);
        
        evoc_update_property($term);  
      }
      
      break;
    
    case 'insert':
      // Create a user friendly alias to the vocabulary node
      if($node->type == NEOLOGISM_CT_VOCABULARY) {
        _neologism_set_aliases($node);
      }
      
      // Update evoc terms repository
      // we don't need to worry about the existence of this term in the respository
      // evoc module check this for us.
      
      // behavior to update evoc's classes list when a new class' content type is added.
      elseif( $node->type == NEOLOGISM_CT_CLASS ) {
        $term = array();
        $term['id'] = $node->title;
        $term['type'] = 'class';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normalize the superclasses array to used by evoc's evoc_write_class() method
        $term[EVOC_SUPERCLASSES] = array();
        if( !empty($node->field_superclass2) && is_array($node->field_superclass2) ) {
          foreach ( $node->field_superclass2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_SUPERCLASSES][] = $value['evoc_term'];
            }
          }
        }
        
      	$term[EVOC_DISJOINTS] = array();
        if( !empty($node->field_disjointwith2) && is_array($node->field_disjointwith2) ) {
          foreach ( $node->field_disjointwith2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DISJOINTS][] = $value['evoc_term'];
            }
          }
        }
        
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        evoc_write_class($term);  
      }
      
      // behavior to update evoc's properties list when a new property's content type is added 
      elseif( $node->type == NEOLOGISM_CT_PROPERTY ) {
        $term = array();
        $term['id'] = $node->title;
        $term['type'] = 'property';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normaliza the evoc's fields
        $term[EVOC_DOMAINS] = array();
        if( !empty($node->field_domain2) && is_array($node->field_domain2) ) {
          foreach ( $node->field_domain2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DOMAINS][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_RANGES] = array();
        if( !empty($node->field_range2) && is_array($node->field_range2) ) {
          foreach ( $node->field_range2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_RANGES][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_SUPERPROPERTIES] = array();
        if( !empty($node->field_superproperty2) && is_array($node->field_superproperty2) ) {
          foreach ( $node->field_superproperty2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_SUPERPROPERTIES][] = $value['evoc_term'];
            }
          }
        }
        
      	//kpr($form);
      	$term[EVOC_INVERSE] = $node->field_inverse2[0]['evoc_term'];
 
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        evoc_write_property($term);  
      }

      break;
    
   
    
    case 'delete':
      // Deletion of the aliases when deleting a vocabulary
      if($node->type == NEOLOGISM_CT_VOCABULARY) {
        _neologism_unset_aliases($node);
        _neologism_on_deleted_vocabulary_node($node);
      } 
      else if($node->type == NEOLOGISM_CT_CLASS) {
        _neologism_on_deleted_class_node($node);
      }
      else if($node->type == NEOLOGISM_CT_PROPERTY) {
        _neologism_on_deleted_property_node($node);
      }
      
      break;

    default:
  }

}

/**
 * hook_removed_external_vocabulary($prefix)
 * this hook is called by evoc module after a namespace is removed from its repository
 * @param object $prefix removed
 * @return 
 */
function neologism_removed_external_vocabulary($prefix) {
  $classes = db_query(db_rewrite_sql("select nid from {node} where type = '%s'"), NEOLOGISM_CT_CLASS);
  while ( $class = db_fetch_object($classes) ) {
    $nclass = (object) node_load($class->nid);
    $need_update = FALSE;
    
    if( isset($nclass->field_superclass2[0]['evoc_term']) ) {
      foreach ( $nclass->field_superclass2 as &$value ) {
        $qname_splitted = explode(':', $value['evoc_term']); 
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( isset($nclass->field_disjointwith2[0]['evoc_term']) ) {
      foreach ( $nclass->field_disjointwith2 as &$value ) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if ( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nclass);
    }
    
  }
  
  // check for properties
  $properties = db_query(db_rewrite_sql("select nid from {node} where type = '%s'"), NEOLOGISM_CT_PROPERTY); 
  while( $property = db_fetch_object($properties) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nproperty = (object) node_load($property->nid);
    $need_update = FALSE;
    
    if( isset($nproperty->field_domain2[0]['evoc_term']) ) {
      foreach($nproperty->field_domain2 as &$value) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( isset($nproperty->field_range2[0]['evoc_term']) ) {
      foreach($nproperty->field_range2 as &$value) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( isset($nproperty->field_superproperty2[0]['evoc_term']) ) {
      foreach($nproperty->field_superproperty2 as &$value) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nproperty);
    }
  } // check for properties
}

//---------------------------------------------------------------------------------------------------
// private functions section

/**
 * update the url_alias table the alias 
 * @param object $node
 * @return 
 */
function _neologism_update_aliases($node) {
  _neologism_unset_aliases($node);
  _neologism_set_aliases($node);
}

/**
 * Create a alias in the url_alias table for the $node 
 * @param object $node
 * @return 
 */
function _neologism_set_aliases($node) {
  $path = check_plain($node->title);
  path_set_alias("node/$node->nid", $path, NULL, $node->language );
  path_set_alias("node/$node->nid/html", $path.'.html', NULL, $node->language);
  path_set_alias("node/$node->nid/rdf", $path.'.rdf', NULL, $node->language);
  path_set_alias("node/$node->nid/ttl", $path.'.ttl', NULL, $node->language);
  path_set_alias("node/$node->nid/ttl", $path.'.n3', NULL, $node->language);
  path_set_alias("node/$node->nid/xml", $path.'.xml', NULL, $node->language);
  path_set_alias("node/$node->nid/layout", $path.'.layout', NULL, $node->language);
}

/**
 * Remove from the url_alias table the alias create for each vocabulary's node
 * @param object $node
 * @return 
 */
function _neologism_unset_aliases($node) {
  path_set_alias(NULL, $node->path, NULL, $node->language);
  path_set_alias(NULL, $node->path.'.html', NULL, $node->language);
  path_set_alias(NULL, $node->path.'.rdf', NULL, $node->language);
  path_set_alias(NULL, $node->path.'.ttl', NULL, $node->language);
  path_set_alias(NULL, $node->path.'.n3', NULL, $node->language);
  path_set_alias(NULL, $node->path.'.xml', NULL, $node->language);
  path_set_alias(NULL, $node->path.'.layout', NULL, $node->language);
}

/**
 * Get all properties in a vocabulary
 */
function _neologism_get_all_properties($node, array &$detect_namespaces = NULL) {
  $properties_resource = db_query(db_rewrite_sql("select n.nid from {content_field_vocabulary} c inner join {node} n on c.nid = n.nid where c.field_vocabulary_nid = %d and n.type = '%s'"), $node->nid, NEOLOGISM_CT_PROPERTY);
  $i = 0;
  
  $properties = array(); 
  while ( $item = db_fetch_object($properties_resource) ) {
    $fullnode = node_load($item->nid);
    
    $properties[$i]['nid'] = $item->nid;
    $properties[$i]['id'] = $fullnode->title;
    $properties[$i]['label'] = $fullnode->field_label[0]['value'];
    if( !empty($fullnode->field_comment[0]['value']) ) {
      $properties[$i]['comment'] = $fullnode->field_comment[0]['value'];
    }
    
    if ( isset($fullnode->field_domain2[0]['evoc_term']) && $fullnode->field_domain2[0]['evoc_term'] ) {
      $properties[$i][DOMAINS] = array();
      foreach ( $fullnode->field_domain2 as $term => $value ) {
        $properties[$i][DOMAINS][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if ( isset($fullnode->field_range2[0]['evoc_term']) && $fullnode->field_range2[0]['evoc_term'] ) {
      $properties[$i][RANGES] = array();
      foreach ( $fullnode->field_range2 as $term => $value ) {
        $properties[$i][RANGES][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if ( isset($fullnode->field_superproperty2[0]['evoc_term']) && $fullnode->field_superproperty2[0]['evoc_term'] ) {
      $properties[$i][SUBPROPERTYOF] = array();
      foreach ( $fullnode->field_superproperty2 as $term => $value ) {
        $properties[$i][SUBPROPERTYOF][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if( isset($fullnode->field_ifp[0]['value']) && $fullnode->field_ifp[0]['value'] == '1' ) {
      $properties[$i]['isInverseFunctional'] = TRUE;
    }
    
    if( isset($fullnode->field_fp[0]['value']) && $fullnode->field_fp[0]['value'] == '1' ) {
      $properties[$i]['isFunctional'] = TRUE;
    }
    
    if( !empty($fullnode->body) ) {
      $properties[$i]['description'] = $fullnode->body;
    }
      
    $i++;
  }
  
  return $properties;
}

/**
 * Get all classes in a vocabulary
 */
function _neologism_get_all_classes($node, array &$detect_namespaces = NULL) {
  
  $classes_resource = db_query(db_rewrite_sql("SELECT n.nid FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_CLASS);
  $i = 0;
  
  $classes = array(); 
  while ( $item = db_fetch_object($classes_resource) ) {
    $fullnode = node_load($item->nid);
    
    $classes[$i]['nid'] = $item->nid;
    $classes[$i]['id'] = $fullnode->title;
    $classes[$i]['label'] = $fullnode->field_label[0]['value'];
    if( !empty($fullnode->field_comment[0]['value']) ) {
      $classes[$i]['comment'] = $fullnode->field_comment[0]['value'];
    }
    
    if ( isset($fullnode->field_superclass2[0]['evoc_term']) && $fullnode->field_superclass2[0]['evoc_term'] ) {
      $classes[$i][SUPERCLASSES] = array();
      foreach ( $fullnode->field_superclass2 as $term => $value ) {
        $classes[$i][SUPERCLASSES][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if ( isset($fullnode->field_disjointwith2[0]['evoc_term']) && $fullnode->field_disjointwith2[0]['evoc_term'] ) {
      $classes[$i][DISJOINTS_WITH] = array();
      foreach ( $fullnode->field_disjointwith2 as $term => $value ) {
        $classes[$i][DISJOINTS_WITH][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if( !empty($fullnode->body) ) {
      $classes[$i]['description'] = $fullnode->body;
    }
      
    $i++;
  }
  
  return $classes;
}


/**
 * Callback launched after a vocabulary node has been deleted. Used in neologism_nodeapi() hook
 * @return none
 * 
 * Handling CCK nodereference orphaned nodes when the parent is deleted?
 * http://drupal.org/node/364539
 * 
 * Inconsistent site left after deleting a parent referenced in a nodereference field
 * http://drupal.org/node/362649 
 */
function _neologism_on_deleted_vocabulary_node($node) {
  //$field_name = 'field_vocabulary';
  //$field = content_fields($field_name); // $field_name is the name of the nodereference field.
  //$db_info = content_database_info($field);
  //$query = 'SELECT nid FROM {'. $db_info['table'] . '} WHERE '. $field_name .'_nid = %d';
  //$result = db_query($query, $node->nid);
  //while ($obj = db_fetch_object($result)) 
  
  // remove all classes belonging to this vocabulary
  $classes = db_query(db_rewrite_sql("SELECT n.nid, n.title FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_CLASS);
  while ($class = db_fetch_object($classes)) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    
    // we need to delete the node without usign node_delete because there is no way to check the vocabulary
    // it belong
    //node_delete($class->nid);
    
    // same code that node_delete but without execute any callback
    $cnode = node_load($class->nid);

    if (node_access('delete', $cnode)) {
      db_query('DELETE FROM {node} WHERE nid = %d', $cnode->nid);
      db_query('DELETE FROM {node_revisions} WHERE nid = %d', $cnode->nid);
  
      // Clear the page and block caches.
      cache_clear_all();
  
      // Remove this node from the search index if needed.
      if (function_exists('search_wipe')) {
        search_wipe($cnode->nid, 'node');
      }
      watchdog('content', '@type: deleted %title.', array('@type' => $cnode->type, '%title' => $cnode->title));
      drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $cnode), '%title' => $cnode->title)));
    }
    
    // check for classes dependence
    _neologism_on_deleted_class_node($cnode, $node->title);
  }
  
  // remove all properties belonging to this vocabulary 
  $properties = db_query(db_rewrite_sql("SELECT n.nid, n.title FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_PROPERTY);
  while ($property = db_fetch_object($properties)) {
    // same code that node_delete but without execute any callback
    $pnode = node_load($property->nid);

    if (node_access('delete', $pnode)) {
      db_query('DELETE FROM {node} WHERE nid = %d', $pnode->nid);
      db_query('DELETE FROM {node_revisions} WHERE nid = %d', $pnode->nid);
  
      // Clear the page and block caches.
      cache_clear_all();
  
      // Remove this node from the search index if needed.
      if (function_exists('search_wipe')) {
        search_wipe($pnode->nid, 'node');
      }
      watchdog('content', '@type: deleted %title.', array('@type' => $pnode->type, '%title' => $pnode->title));
      drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $pnode), '%title' => $pnode->title)));
    }
    
    // check for properies dependence
    _neologism_on_deleted_property_node($pnode, $node->title);
  }
}

/**
 * 
 * @param object $node
 * @param object $vocabulary_title [optional]
 * @return 
 */
function _neologism_on_deleted_class_node($node, $vocabulary_title = NULL) {
  // at this point the current class has been removed. 
  // now we have to check for other classes or properties that might be subClasses or disjoints 
  // or properties that might has been using it as domain or range.
  
  if( !$vocabulary_title ) {
    $vocabulary_title = db_fetch_object( db_query( db_rewrite_sql("SELECT n.title FROM {node} n WHERE n.nid = %d"), $node->field_vocabulary[0]['nid']) );
    $vocabulary_title = $vocabulary_title->title;  
  }
  
  // check for classes
  $classes = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = '%s'"), NEOLOGISM_CT_CLASS); 
  while( $class = db_fetch_object($classes) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nclass = (object) node_load($class->nid);
    $need_update = FALSE;
    
    foreach($nclass->field_superclass2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        // if this is the only one superclass assign it the default superclass
        if( count($nclass->field_superclass2) > 0 ) {
          $value['evoc_term'] = $node->field_superclass2[0]['evoc_term'];
        }
        else {
          $value['evoc_term'] = NULL;
        }
        $need_update = TRUE;
      }
    }
    
    foreach($nclass->field_disjointwith2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nclass);
    }
    
  }
  
  // check for properties
  $properties = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = '%s'"), NEOLOGISM_CT_PROPERTY); 
  while( $property = db_fetch_object($properties) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nproperty = (object) node_load($property->nid);
    $need_update = FALSE;
    
    foreach($nproperty->field_domain2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    foreach($nproperty->field_range2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nproperty);
    }
  } // check for properties
  
  // remove the class for evoc repository
  $term = array();
  $term['id'] = $node->title;
  $term['prefix'] = $vocabulary_title;
  evoc_remove_class($term);
}

/**
 * 
 * @param object $node
 * @param object $vocabulary_title [optional]
 * @return 
 */
function _neologism_on_deleted_property_node($node, $vocabulary_title = NULL) {
  watchdog('content', '@type: deleted %title.', array('@type' => $node->type, '%title' => $node->title));
  drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $node), '%title' => $node->title)));
  
  if( !$vocabulary_title ) {
    $vocabulary_title = db_fetch_object( db_query( db_rewrite_sql("SELECT n.title FROM {node} n WHERE n.nid = %d"), $node->field_vocabulary[0]['nid']) );
    $vocabulary_title = $vocabulary_title->title;  
  }
  
  // at this point the current property node has been removed.Now we have to check for other properties
  // that might be subPropertyOf that class.
  // check for properties
  $properties = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = '%s'"), NEOLOGISM_CT_PROPERTY); 
  while( $property = db_fetch_object($properties) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nproperty = (object) node_load($property->nid);
    $need_update = FALSE;
    
    foreach($nproperty->field_superproperty2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nproperty);
    }
  } 
  
   // remove the class for evoc repository
  $term = array();
  $term['id'] = $node->title;
  $term['prefix'] = $vocabulary_title;
  evoc_remove_property($term);
}

function _neologism_is_valid_id($string) {
  return ( ereg("^[a-zA-Z_]+[a-zA-Z0-9._-]*", $string, $reg) == strlen($string)); 
  //return (preg_match("/^[a-zA-Z_]+[a-zA-Z0-9._-]*/", $string) == strlen($string));
}

/**
 * This function is a wrapper function to fix the bug in rdfapi when localpart contain the prefix #
 * @param object $uri
 * @return 
 */
function neologism_rdf_uri_to_qname($uri) {
  $qname = rdf_uri_to_qname($uri);
  $qname_parts = explode(':', $qname);
  // TODO check for external vocabulary when this is missing and import it automatically
  if ( $pos = strpos($qname_parts[1], '#') !== false ) {
    $qname_parts[1] = substr($qname_parts[1], $pos);  
  } 
  return implode(':', $qname_parts);
}

/**
 * hook_evoc_widgetbehaviour_preprocess executed before a evoc_widgetbehaviour is bing shown
 * @param $field_name
 * @param $default_of_values
 * @param $extra_values
 * @return unknown_type
 */
function neologism_evoc_widgetbehaviour_preprocess($field_name, $default_of_values, $extra_values) {
	$result = array();
	
	switch ($field_name) {
		case 'field_superclass2':
			// we need to preprocess this field because at this time we have added to the list of value other super class
			// but we need to check if there is other class that might be super class of this class that is currently analyzing
			
			// in our case it is very simply just assing the extra_values to the result_list_of_values
			$result = $extra_values;
			break;
			
		case 'field_superproperty2':
			$result = $extra_values;
			break;
	}
	
	return $result;
}

/**
 * Compare the string hold by array the arrays $a['id] and $b['id'] using the strcmp function.
 * This function is the cmp_function used by "bool usort ( array &$array , callback $cmp_function )" function to
 * sort and array.
 * This functio return an integer less than, equal to, or greater than zero if the first argument is considered to be 
 * respectively less than, equal to, or greater than the second.
 * @param $a array
 * @param $b array
 * @return int
 */
function _neologism_cmp_2array_alphabetically($a, $b)
{
	return strcmp($a['id'], $b['id']);
}

/**
 * 
 * @param $value
 * @return unknown_type
 */
function _neologism_is_literal_datatype( $value ) {
  $literal_datatypes = neologism_get_literal_datatype_list();
  foreach ( array_values($literal_datatypes) as $group ) {
  	if( isset($group[$value]) ) {
  		return TRUE;
  	}	
  }
  
  return FALSE;
}

/**
 * 
 * @return unknown_type
 */
function neologism_get_literal_datatype_list() {
	$neologism_literal_datatypes = array(
			t('Standard datatypes') => array(
				'rdfs:Literal' => 'rdfs:Literal',
				'xsd:string' => 'xsd:string',
				'xsd:decimal' => 'xsd:decimal',
				'xsd:integer' => 'xsd:integer',
				'xsd:date' => 'xsd:date',
				'xsd:dateTime' => 'xsd:dateTime',
				'xsd:boolean' => 'xsd:boolean',
				'rdf:XMLLiteral' => 'rdf:XMLLiteral'	
			),
			t('Date and time') => array(
				'xsd:date' => 'xsd:date',
				'xsd:dateTime' => 'xsd:dateTime',
				'xsd:time' => 'xsd:time',
				'xsd:gYearMonth' => 'xsd:gYearMonth',
				'xsd:gYear' => 'xsd:gYear',
				'xsd:gMonthDay' => 'xsd:gMonthDay',
				'xsd:time' => 'xsd:time',
				'xsd:gDay' => 'xsd:gDay',
				'xsd:gMonth' => 'xsd:gMonth'
			),
			t('Numbers') => array(
				'xsd:decimal' => 'xsd:decimal',
				'xsd:float' => 'xsd:float',
				'xsd:double' => 'xsd:double',
				'xsd:integer' => 'xsd:integer',
				'xsd:nonPositiveInteger' => 'xsd:nonPositiveInteger',
				'xsd:negativeInteger' => 'xsd:negativeInteger',
				'xsd:long' => 'xsd:long',
				'xsd:int' => 'xsd:int',
				'xsd:short' => 'xsd:short',
				'xsd:byte' => 'xsd:byte',
				'xsd:nonNegativeInteger' => 'xsd:nonNegativeInteger',
				'xsd:unsignedLong' => 'xsd:unsignedLong',
				'xsd:unsignedInt' => 'xsd:unsignedInt',
				'xsd:unsignedShort' => 'xsd:unsignedShort',
				'xsd:unsignedByte' => 'xsd:unsignedByte',
				'xsd:unsignedInt' => 'xsd:unsignedInt'
			),
			t('Other') => array(
				'xsd:hexBinary' => 'xsd:hexBinary',
				'xsd:base64Binary' => 'xsd:base64Binary',
				'xsd:anyURI' => 'xsd:anyURI',
				'xsd:normalizedString' => 'xsd:normalizedString',
				'xsd:token' => 'xsd:token',
				'xsd:language' => 'xsd:language',
				'xsd:NMTOKEN' => 'xsd:NMTOKEN',
				'xsd:Name' => 'xsd:Name',
				'xsd:NCName' => 'xsd:NCName'
			)
	  );
	return $neologism_literal_datatypes;
}

/**
 * 
 * @param unknown_type $node
 * @return unknown_type
 */
function _neologism_vocabulary_save(&$vocabulary) {
	//$node_save($vocabulary);	
  global $user;

  if (!empty($vocabulary->revision)) {
    // When inserting a node, $node->log must be set because
    // {node_revisions}.log does not (and cannot) have a default
    // value.  If the user does not have permission to create
    // revisions, however, the form will not contain an element for
    // log so $node->log will be unset at this point.
    if (!isset($vocabulary->log)) {
      $vocabulary->log = '';
    }
  }
  elseif (empty($vocabulary->log)) {
    // When updating a node, however, avoid clobbering an existing
    // log entry with an empty one.
    unset($vocabulary->log);
  }

  // Save the old revision if needed.
  if (!empty($vocabulary->revision) && $vocabulary->vid) {
    $vocabulary->old_vid = $vocabulary->vid;
  }

  $time = time();
  if (empty($vocabulary->created)) {
    $vocabulary->created = $time;
  }
  // The changed timestamp is always updated for bookkeeping purposes (revisions, searching, ...)
  $vocabulary->changed = $time;

  $vocabulary->timestamp = $time;
  $vocabulary->format = isset($vocabulary->format) ? $vocabulary->format : FILTER_FORMAT_DEFAULT;

  // Generate the node table query and the node_revisions table query.
  drupal_write_record('node', $vocabulary, 'nid');
  if (!empty($vocabulary->revision)) {
    _node_save_revision($vocabulary, $user->uid);
    db_query('UPDATE {node} SET vid = %d WHERE nid = %d', $vocabulary->vid, $vocabulary->nid);
  }
  else {
    _node_save_revision($vocabulary, $user->uid, 'vid');
  }

  // Update the node access table for this node.
  //node_access_acquire_grants($node);

  // Clear the page and block caches.
  //cache_clear_all();
}
