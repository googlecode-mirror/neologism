<?php
// $Id: rdfcck.module,v 1.1.2.8 2008/11/07 20:03:31 scor Exp $

/**
 * @file
 * Defines mappings between CCK fields and RDF, and exports nodes as RDF.
 */

/**
 * Implementation of hook_perm().
 */
function evoc_perm() {
}

/**
 * Implementation of hook_menu().
 */
function evoc_menu() {
  $items = array();

  $items['evoc'] = array(
    'title' => 'evoc',
    'description' => "View, edit, and delete your site's content.",
    'page callback' => 'evoc_evoc',
    'access arguments' => array('administer nodes'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function evoc_evoc() {
  global $rdf_namespaces;
  rdf_get_namespaces();
var_dump($rdf_namespaces);
//var_dump(rdf_get_namespaces());

/////////////////////////
// Example of input
$ns = 'http://xmlns.com/foaf/0.1/';
$prefix = 'foaf';
$terms = array();
$terms[] = array('type' => 'class', 'id' => 'Project');
$terms[] = array('type' => 'class', 'id' => 'Organization');
$terms[] = array('type' => 'class', 'id' => 'OnlineAccount');
$terms[] = array('type' => 'class', 'id' => 'Document');
$terms[] = array('type' => 'class', 'id' => 'Agent');
$terms[] = array('type' => 'class', 'id' => 'Image');
$terms[] = array('type' => 'class', 'id' => 'Person');
$terms[] = array('type' => 'class', 'id' => 'Group');
$terms[] = array('type' => 'class', 'id' => 'OnlineGamingAccount');
$terms[] = array('type' => 'class', 'id' => 'OnlineChatAccount');
$terms[] = array('type' => 'class', 'id' => 'PersonalProfileDocument');
$terms[] = array('type' => 'class', 'id' => 'OnlineEcommerceAccount');
$terms[] = array('type' => 'property', 'id' => 'mbox');
$terms[] = array('type' => 'property', 'id' => 'made');
$terms[] = array('type' => 'property', 'id' => 'knows');
$terms[] = array('type' => 'property', 'id' => 'gender');
/////////////////////////




// typical input data given by the user via a form.
$vocabulary_uri = 'http://xmlns.com/foaf/0.1/';
$vocabulary_prefix = 'foaf';
//$vocabulary_uri = 'http://rdfs.org/sioc/ns#';
//$vocabulary_prefix = 'sioc';


if (!in_array($vocabulary_uri, $rdf_namespaces)) {
  // Add momentarily the namespace in memory to be able to convert the URIs to QNames.
  $rdf_namespaces[$vocabulary_prefix] = $vocabulary_uri;
}
//var_dump($rdf_namespaces);

// Typical SPARQL query to retrieve properties/classes, working for at least FOAF...
$q_classes = "prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
select *
from <$vocabulary_uri>
where {?class rdf:type rdfs:Class}
limit 100";

$q_properties = "prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
select *
from <$vocabulary_uri>
where {?class rdf:type rdf:Property}
limit 100";

// FIXME in sparql module.
require_once drupal_get_path('module', 'sparql') . '/sparql.client.inc';

$sparql_res = sparql_request('http://srvgal65.deri.ie:2020/sparql', $q_properties);
//var_dump($sparql_res);

// Parse the SPARQL results and extract the relevant terms.
$terms_to_import = array();
foreach ($sparql_res as $term) {
  $term_qname = rdf_uri_to_qname($term['class']->uri);
  $term_qname_parts = explode(':', $term_qname);
  $term_prefix = $term_qname_parts[0];
  $term_id = $term_qname_parts[1];
  // We only import the terms with the specified prefix.
  if ($term_prefix == $vocabulary_prefix) {
    $terms_to_import[] = array('type' => 'property', 'id' => $term_id);
    drupal_set_message("$term_qname selected to imported.");
  }
  else {
    drupal_set_message("$term_qname discarded.");
  }
}

// Clean up the terms to import and remove any duplicate.
//var_dump($terms_to_import);

_evoc_save_rdf_terms($ns, $prefix, $terms_to_import);

return 'e';
}


/**
 * Handle the creation or update of a set of RDF terms of a given namespace.
 */
function _evoc_save_rdf_terms($ns, $prefix, $terms) {
//var_dump(func_get_args());
//exit;

  drupal_set_message("----------- starting the import ---------------");


  // Namespace management.
  
  // Get the existing namespaces stored in the system.
  // Here we want to make sure we have the namespace stored in the db in case
  // the module defining this ns in hook_rdf_namespaces() is disabled.
  $rdf_namespaces = rdf_db_rdf_namespaces();
  
  var_dump($rdf_namespaces);
  if (!in_array($ns, $rdf_namespaces)) { //FIXME: check also the prefix and raise a warning
    db_query("INSERT INTO {rdf_namespaces} (prefix, uri) VALUES ('%s', '%s')", $prefix, $ns);
    drupal_set_message(t('The namespace has been created.'));
  }
  elseif ($rdf_namespaces[$prefix] != $ns) {
    db_query("UPDATE {rdf_namespaces} SET prefix = '%s', uri = '%s' WHERE prefix = '%s'", $prefix, $uri, $key);
    drupal_set_message(t('The namespace has been updated.'));
  }
  
  // RDF terms management.
  foreach ($terms as $term) {
    // Check whether this term is already in the system.
    // TODO optimize this by loading the whole prefix terms from the db and then check against it in memory
    $res = db_query(db_rewrite_sql('SELECT tid FROM {evoc_rdf_terms} WHERE prefix="%s" AND id = "%s"'), $prefix, $term['id']);

    if (!db_fetch_object($res)) {
      db_query("INSERT INTO {evoc_rdf_terms} (type, prefix, id) VALUES ('%s', '%s', '%s')", $term['type'], $prefix, $term['id']);  
      drupal_set_message("$prefix:" . $term['id'] . " successfully imported.");
    }
    else {
      drupal_set_message("$prefix:" . $term['id'] . " already exists in the system.");
    }

  }

}








