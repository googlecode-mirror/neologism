<?php
// $Id: rdfcck.module,v 1.1.2.8 2008/11/07 20:03:31 scor Exp $

/**
 * @file
 * Defines mappings between CCK fields and RDF, and exports nodes as RDF.
 */

/**
 * Implementation of hook_perm().
 */
function evoc_perm() {
}

/**
 * Implementation of hook_init().
 */
function evoc_init() {
  drupal_add_css(drupal_get_path('module', 'evoc') .'/evoc.css');
}

/**
 * Implementation of hook_menu().
 */
function evoc_menu() {
  $items = array();

  $items['evoc'] = array(
    'title' => 'evoc',
    'description' => "View, edit, and delete your site's content.",
    'page callback' => 'evoc_evoc',
    'access arguments' => array('administer nodes'),
    'type' => MENU_CALLBACK,
  );
  $items['evoc/import'] = array(
    'title' => 'Import vocabulary',
    'description' => "Import RDF terms of an external vocabulary.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('evoc_import_form'),
    'access arguments' => array('administer nodes'),
  );
//   $items['evoc/uri'] = array(
//     'title' => 'Link to a URI',
//     'description' => "",
//     'page callback' => 'drupal_get_form',
//     'page arguments' => array('evoc_uri_form'),
//     'access arguments' => array('administer nodes'),
//   );
  $items['evoc/js'] = array(
    'title' => 'Javascript Choice Form',
    'page callback' => 'evoc_js',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

// Add the SPARQL lookup in the node add/edit form.
function evoc_form_alter(&$form, $form_state, $form_id) {
  if ($form['#id'] == 'node-form') {


// $form['field_link'][0]['#description'] = 'scor';
// //var_dump($form['field_link']);
// 
// 
//   $form['sparql_lookup'] = array(
//     '#title' => t('SPARQL lookup'),
//     '#prefix' => '<div class="clear-block" id="sparql-lookup-wrapper">', // This is our wrapper div.
//     '#suffix' => '</div>',
//     '#tree' => TRUE,
//   );
// //var_dump(ahah_helper_path(array('sparql_lookup')));
//   $form['sparql_lookup']['keyword'] = array(
//     '#type' => 'textfield',
//     '#title' => t('Vocabulary URI'),
//     '#required' => TRUE,
//     '#default_value' => $form_state['values']['sparql_lookup']['keyword'],
//     '#prefix' => '<div class="clear-block">',
//     '#suffix' => '</div>',
//     '#ahah' => array(
//       'event' => 'change',
//       'effect' => 'fade',
//       // This is the "magical path". Note that the parameter is an array of
//       // the parents of the form item of the wrapper div!
//       'path' => ahah_helper_path(array('sparql_lookup')),
//       'wrapper' => 'sparql-lookup-wrapper',
//       'progress' => array('type' => 'bar', 'message' => t('Please wait while suggested URIs are retrieved...')),
//     ),
//   );
//   if ($form_state['values']['sparql_lookup']['keyword'] ) {
//     $form['sparql_lookup']['uri_choices'] = array(
// 			'#type' => 'radios',
// 			'#title' => t('Suggested URIs'),
// 			'#default_value' => '',
// 			'#options' => array(
// 				'status' => t('Published'),
// 				'moderate' => t('In moderation queue'),
// 				'promote' => t('Promoted to front page'),
// 				'sticky' => t('Sticky at top of lists'),
// 				'revision' => t('Create new revision'),
// 			),
// 			'#description' => t('Choose the URI which describes the best what you want to represent.'),
//     );
//   }
// //var_dump($form);
// 
  
  
  }


return $form;


}

function evoc_uri_form($form_state) {
  $form['sparql_lookup'] = array(
    '#title' => t('SPARQL lookup'),
    '#prefix' => '<div class="clear-block" id="sparql-lookup-wrapper">', // This is our wrapper div.
    '#suffix' => '</div>',
    '#tree' => TRUE,
  );
  $form['sparql_lookup']['keyword'] = array(
    '#type' => 'textfield',
    '#title' => t('Vocabulary URI'),
    '#required' => TRUE,
    '#default_value' => $form_state['values']['sparql_lookup']['keyword'],
    '#prefix' => '<div class="clear-block">', // This is our wrapper div.
    '#suffix' => '</div>',
    '#ahah' => array(
      'event' => 'change',
      'effect' => 'fade',
      // This is the "magical path". Note that the parameter is an array of
      // the parents of the form item of the wrapper div!
      'path' => ahah_helper_path(array('sparql_lookup')),
      'wrapper' => 'sparql-lookup-wrapper',
      'progress' => array('type' => 'bar', 'message' => t('Please wait while suggested URIs are retrieved...')),
    ),
  );

  // If 'company' is selected, then these two form items will be displayed.
  if ($form_state['values']['sparql_lookup']['keyword'] ) {
  sleep(2);
    $form['sparql_lookup']['uri_choices'] = array(
			'#type' => 'radios',
			'#title' => t('Suggested URIs'),
			'#default_value' => '',
			'#options' => array(
				'status' => t('Published'),
				'moderate' => t('In moderation queue'),
				'promote' => t('Promoted to front page'),
				'sticky' => t('Sticky at top of lists'),
				'revision' => t('Create new revision'),
			),
			'#description' => t('Choose the URI which describes the best what you want to represent.'),
    );
  }


  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
  );
  return $form;

/*
  // Add a wrapper for the choices and more button.
  $form['choice_wrapper'] = array(
    '#tree' => FALSE,
    '#prefix' => '<div class="clear-block" id="poll-choice-wrapper">',
    '#suffix' => '</div>',
  );
  // Container for just the poll choices.
  $form['choice_wrapper']['choice'] = array(
    '#prefix' => '<div id="poll-choices">',
    '#suffix' => '</div>',
    '#theme' => 'poll_choices',
  );

  // We name our button 'poll_more' to avoid conflicts with other modules using
  // AHAH-enabled buttons with the id 'more'.
  $form['choice_wrapper']['poll_more'] = array(
    '#type' => 'submit',
    '#value' => t('More choices'),
    '#description' => t("If the amount of boxes above isn't enough, click here to add more choices."),
    '#weight' => 1,
    '#submit' => array('poll_more_choices_submit'), // If no javascript action.
    '#ahah' => array(
      'path' => 'evoc/js',
      'wrapper' => 'poll-choices',
      'method' => 'replace',
      'effect' => 'fade',
    ),
  );
*/

}


function evoc_js() {
//$output = "<p>hi</p>";
//sleep(1);

//$output = var_export($_POST, TRUE);
//  drupal_json(array('status' => TRUE, 'data' => $output));
//return;

  // Build our new form element.
//  $form_element = _poll_choice_form($delta);
  $form_element = array(
    '#tree' => TRUE,
  );

  // We'll manually set the #parents property of these fields so that
  // their values appear in the $form_state['values']['choice'] array.
  $form_element['chtext'] = array(
    '#type' => 'textfield',
    '#title' => t('Choice @n', array('@n' => ($delta + 1))),
    '#default_value' => $value,
    '#parents' => array('choice', $delta, 'chtext'),
  );

  drupal_alter('form', $form_element, array(), 'poll_choice_js');

  // Build the new form.
  $form_state = array('submitted' => FALSE);
  $form_build_id = $_POST['form_build_id'];
  // Add the new element to the stored form. Without adding the element to the
  // form, Drupal is not aware of this new elements existence and will not
  // process it. We retreive the cached form, add the element, and resave.
  if (!$form = form_get_cache($form_build_id, $form_state)) {
    exit();
  }
  $form['choice_wrapper']['choice'][$delta] = $form_element;
  form_set_cache($form_build_id, $form, $form_state);
  $form += array(
    '#post' => $_POST,
    '#programmed' => FALSE,
  );

  // Rebuild the form.
  $form = form_builder('poll_node_form', $form, $form_state);

  // Render the new output.
  $choice_form = $form['choice_wrapper']['choice'];
  unset($choice_form['#prefix'], $choice_form['#suffix']); // Prevent duplicate wrappers.
  $choice_form[$delta]['#attributes']['class'] = empty($choice_form[$delta]['#attributes']['class']) ? 'ahah-new-content' : $choice_form[$delta]['#attributes']['class'] .' ahah-new-content';
  $choice_form[$delta]['chvotes']['#value'] = 0;
  $output = theme('status_messages') . drupal_render($choice_form);

  drupal_json(array('status' => TRUE, 'data' => $output));
}


function evoc_uri_form_submit($form, &$form_state) {
  $form_state['storage']['values'] = $form_state['values'];
  $form_state['rebuild'] = true;

}


function evoc_import_form($form_state) {
  $form['ns_uri'] = array(
    '#type' => 'textfield',
    '#title' => t('Vocabulary URI'),
    '#required' => TRUE,
    '#default_value' => $form_state['values']['ns_uri'],
    '#description' => "Enter the URI of the vocabulary to import. Make sure it finishes by either / or #.",
  ); 
  $form['prefix'] = array(
    '#type' => 'textfield',
    '#title' => t('Prefix'),
    '#required' => TRUE,
    '#default_value' => $form_state['values']['prefix'],
    '#description' => "Choose a prefix for this vocabulary.",
  ); 
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
  );
  return $form;
}
function evoc_import_form_submit($form, &$form_state) {
  $form_state['storage']['values'] = $form_state['values'];
  $form_state['rebuild'] = true;

  evoc_import_vocabulary($form_state['values']['ns_uri'], $form_state['values']['prefix']);
}

/*
/////////////////////////
// Example of input
$ns = 'http://xmlns.com/foaf/0.1/';
$prefix = 'foaf';
$terms = array();
$terms[] = array('type' => 'class', 'id' => 'Project');
$terms[] = array('type' => 'class', 'id' => 'Organization');
$terms[] = array('type' => 'class', 'id' => 'OnlineAccount');
$terms[] = array('type' => 'property', 'id' => 'made');
$terms[] = array('type' => 'property', 'id' => 'knows');
$terms[] = array('type' => 'property', 'id' => 'gender');
/////////////////////////




// typical input data given by the user via a form.
//$vocabulary_uri = '';
//$vocabulary_prefix = '';

$vocabulary_uri = 'http://xmlns.com/foaf/0.1/';
$vocabulary_prefix = 'foaf';

$vocabulary_uri = 'http://rdfs.org/sioc/ns#';
$vocabulary_prefix = 'sioc';

$vocabulary_uri = 'http://www.w3.org/2008/05/skos#';
$vocabulary_prefix = 'skos';

$vocabulary_uri = 'http://usefulinc.com/ns/doap#';
$vocabulary_prefix = 'doap';

$vocabulary_uri = 'http://purl.org/dc/elements/1.1/';
$vocabulary_prefix = 'dc';

$vocabulary_uri = 'http://purl.org/dc/terms/';
$vocabulary_prefix = 'dcterms';

$vocabulary_uri = 'http://purl.org/dc/dcmitype/';
$vocabulary_prefix = 'dcmitype';

// not working because the uri for the voc is not the same as http://ramonantonio.net/doac/0.1/
// note also weird URIs like http://ramonantonio.net/doac/0.1/#Skill (double /#)
$vocabulary_uri = 'http://ramonantonio.net/content/xml/doac01';
$vocabulary_prefix = 'doac';

// http://rdfs.org/resume-rdf/
// points to 2 differents documents:
// 1. 

$vocabulary_uri = 'http://rdfs.org/ns/void#';
$vocabulary_prefix = 'void';

*/

function evoc_import_vocabulary($vocabulary_uri, $vocabulary_prefix) {
  $fetched_terms = evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix);
var_dump($fetched_terms);
  _evoc_save_rdf_terms($vocabulary_uri, $vocabulary_prefix, $fetched_terms);
}


// This is an API function which is used by other modules to fetch a vocabulary.
function evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix, $ignore_base_ns = FALSE) {
  global $rdf_namespaces;
  rdf_get_namespaces();




// TODO make sure the URI is valid either finishing with / or #
// TODO make sure the prefix and the terms are not containing any forbidden characters.


if (!in_array($vocabulary_uri, $rdf_namespaces)) {
  // Add momentarily the namespace in memory to be able to convert the URIs to QNames.
  $rdf_namespaces[$vocabulary_prefix] = $vocabulary_uri;
}
//var_dump($rdf_namespaces);


// SPARQL queries are stored in an array.
$term_queries = array();
// Typical SPARQL queries to retrieve properties/classes, working for at least FOAF...
$term_queries[] = array('type' => 'class',
                   'query' => "
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
select *
from <$vocabulary_uri>
where {
?class rdf:type rdfs:Class.
OPTIONAL {?class rdfs:label ?label}.
OPTIONAL {?class rdfs:subClassOf ?superclass}.
OPTIONAL {?class rdfs:comment ?comment}.
}
limit 1000
");
$term_queries[] = array('type' => 'property',
                   'query' => "
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
select *
from <$vocabulary_uri>
where {
?property rdf:type rdf:Property.
OPTIONAL {?property rdfs:label ?label}.
OPTIONAL {?property rdfs:domain ?domain}.
OPTIONAL {?property rdfs:range ?range}.
OPTIONAL {?property rdfs:comment ?comment}.
}
limit 1000
");
// for SIOC...
$term_queries[] = array('type' => 'class',
                   'query' => "
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix owl: <http://www.w3.org/2002/07/owl#>
select *
from <$vocabulary_uri>
where {
?class rdf:type owl:Class.
OPTIONAL {?class rdfs:label ?label}.
OPTIONAL {?class rdfs:subClassOf ?superclass}.
OPTIONAL {?class rdfs:comment ?comment}.
}
limit 1000
");
$term_queries[] = array('type' => 'property',
                   'query' => "
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix owl: <http://www.w3.org/2002/07/owl#>
select *
from <$vocabulary_uri>
where {
?property rdf:type owl:ObjectProperty.
OPTIONAL {?property rdfs:label ?label}.
OPTIONAL {?property rdfs:domain ?domain}.
OPTIONAL {?property rdfs:range ?range}.
OPTIONAL {?property rdfs:comment ?comment}.
}
limit 1000
");



// FIXME in sparql module.
require_once drupal_get_path('module', 'sparql') . '/sparql.client.inc';

// Loop through all the various queries in order to extract as many classes and properties as possible.
$fetched_terms = array();
foreach ($term_queries as $query) {
	$sparql_res = sparql_request('http://srvgal65.deri.ie:2020/sparql', $query['query']);
//	var_dump($sparql_res);
	
	// Parse the SPARQL results and extract the relevant terms.
	foreach ($sparql_res as $res_term) {
	  if (isset($res_term['class'])) {
	    $type = 'class';
	  }
	  elseif (isset($res_term['property'])) {
	    $type = 'property';
	  };
	  
		$term_qname = rdf_uri_to_qname($res_term[$type]->uri);
		$term_qname_parts = explode(':', $term_qname);
		$term_prefix = $term_qname_parts[0];

	  $term = array();
		$term['id'] = $term_qname_parts[1];
		$term['type'] = $type;
    $term['label'] = $res_term['label']->value ? $res_term['label']->value : $res_term['label'];
    $term['comment'] = $res_term['comment']->value ? $res_term['comment']->value : $res_term['comment'];
		switch ($type) {
		  case 'class' :
        $term['superclass'] = _evoc_extract_term_id($res_term['superclass']->uri);
		    break;
		  
		  case 'property' :
		    // Extract some information like domain and range.
        $term['domain'] = _evoc_extract_term_id($res_term['domain']->uri);
        $term['range'] = _evoc_extract_term_id($res_term['range']->uri);
        break;

		}
// 		var_dump($term_prefix);
// 		var_dump($vocabulary_prefix);
		// We only import the terms with the specified prefix unless $ignore_base_ns is TRUE.
		// API CHANGE: $term_id becomes $term['id'] and $term will contain information about the term.
		if ($term_prefix == $vocabulary_prefix || $ignore_base_ns) {
			$fetched_terms[] = $term;
//			drupal_set_message("$term_qname selected to imported.");
		}
		else {
//			drupal_set_message("$term_qname discarded.");
		}
	}

}
// @TODO Clean up the terms to import and remove any duplicate? SPARQL should have done that already.

//var_dump($fetched_terms);


return $fetched_terms;
}

function _evoc_extract_term_id($uri) {
	$term_qname = rdf_uri_to_qname($uri);
	$term_qname_parts = explode(':', $term_qname);
	return $term_qname_parts[1];

}


/**
 * Handle the creation or update of a set of RDF terms of a given namespace.
 */
function _evoc_save_rdf_terms($ns, $prefix, $terms) {
  // Namespace management.  
  // Get the existing namespaces stored in the system.
  // Here we want to make sure we have the namespace stored in the db in case
  // the module defining this ns in hook_rdf_namespaces() is disabled.
  $rdf_namespaces = rdf_db_rdf_namespaces();
  
  //var_dump($rdf_namespaces);
  if (!in_array($ns, $rdf_namespaces)) { //FIXME: check also the prefix and raise a warning
    db_query("INSERT INTO {rdf_namespaces} (prefix, uri) VALUES ('%s', '%s')", $prefix, $ns);
    drupal_set_message(t("The namespace for $prefix has been created."));
  }
  elseif ($rdf_namespaces[$prefix] != $ns) {
    db_query("UPDATE {rdf_namespaces} SET prefix = '%s', uri = '%s' WHERE prefix = '%s'", $prefix, $uri, $key);
    drupal_set_message(t('The namespace has been updated.'));
  }
  
  // RDF terms management.
  foreach ($terms as $term) {
    // Check whether this term is already in the system.
    // TODO optimize this by loading the whole prefix terms from the db and then check against it in memory
    $res = db_query(db_rewrite_sql('SELECT tid FROM {evoc_rdf_terms} WHERE prefix="%s" AND id = "%s"'), $prefix, $term['id']);

    if (!db_fetch_object($res)) {
      db_query("INSERT INTO {evoc_rdf_terms} (type, prefix, id, comment) VALUES ('%s', '%s', '%s', '%s')", $term['type'], $prefix, $term['id'], $term['comment']);  
      drupal_set_message("$prefix:" . $term['id'] . " successfully imported.");
    }
    else {
      drupal_set_message("$prefix:" . $term['id'] . " already exists in the system.");
    }

  }

}



/**
* Implementation of hook_rdf_repositories().
*/
function evoc_rdf_repositories() {
  $repos = array();
    $repos['evoc'] = array(
      'title'      => 'evoc CCK',
      'type'       => 'local',
      'persistent' => TRUE,
      'mutable'    => TRUE,
      'enabled'    => TRUE,
      'statements' => 0,
      'callbacks'  => array(
        'insert'   => array(
          'function' => 'evoc_rdf_insert',
          'arguments' => array($table)
        ),
        'delete'   => array(
          'function' => 'evoc_rdf_delete',
          'arguments' => array($table)
        ),
        'query'    => array(
          'function' => 'evoc_rdf_query',
          'arguments' => array($table)
        ),
      ),
    );
  return $repos;
}


/**
 * Implementation of hook_rdf_query().
 */
function evoc_rdf_query($table, $subject, $predicate, $object, array $options = array()) {
//echo 'enter evoc_rdf_query';
//var_dump($table);
//  $result = db_query(_rdf_db_sql_select($table, $subject, $predicate, $object, $options));
//var_dump(func_get_args());
//   $data = array();
//   while ($row = db_fetch_object($result)) {
//     $object = $row->o ? rdf_uriref($row->o) : rdf_literal($row->data, $row->lang, $row->type);
//     $data[] = array($row->s, $row->p, $object);
//   }
//   $data[] = array('a', rdf_qname_to_uriref('rdfs:Resource'), rdf_literal('e'));
//   return $data;
}

// rdf_qname_to_uriref('rdfs:Resource')


