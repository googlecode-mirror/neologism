<?php

/**
 * Neologism Module
 * Allows users to easily publish their own vocabulary online
 */

define("NEOLOGISM", "neologism");
define("HTML", "html");
define("RDF", "rdf");
define("N3", "n3");
define("XML", "xml");
define("LAYOUT", "layout");

define("CONTENT_NEGOTATION_DIR", drupal_get_path('module', NEOLOGISM)."/includes/content_negotiation/");
define("NEOLOGISM_CT_VOCABULARY", "neo_vocabulary");
define("NEOLOGISM_CT_CLASS", "neo_class");
define("NEOLOGISM_CT_PROPERTY", "neo_property");

define("DEFAULT_RDFS_SUPERCLASS", "rdfs:Resource");

define("MSG_INVALID_ID", "is not a valid identifier. It should start with a letter, and should contain only letters, 
													numbers, dashes, and underscores.");

define("MSG_ID_ALREADY_IN_USE", "is a duplicate identifier."); 
define("MSG_ID_ALREADY_EXISTS", "Already exists into the system. Please try with other vocabulary Id.");   
define("MSG_ID_ALREADY_IN_USE_FOR_DRUPAL", "This vocabulary Id is being used by the system path. Please try with other vocabulary Id.");

define("DISJOINTS_WITH", "disjointwith");
define("SUPERCLASSES", "superclasses");
define("DOMAINS", "domains");
define("RANGES", "ranges");
define("SUBPROPERTYOF", "subpropertyof");
define("INVERSE", "inverse");

// persmission definitions
define("PERMISSION_EDIT_VOCABULARIES", "edit vocabularies");
define("PERMISSION_IMPORT_VOCABULARIES", "import vocabularies");
define("PERMISSION_NEOLOGISM_ACCESS", "access vocabularies");

define("NEOLOGISM_VOCABULARY_FORM_ID", NEOLOGISM_CT_VOCABULARY."_node_form");
define("NEOLOGISM_PROPERTY_FORM_ID", NEOLOGISM_CT_PROPERTY."_node_form"); // neo_property_node_form
define("NEOLOGISM_CLASS_FORM_ID", NEOLOGISM_CT_CLASS."_node_form"); // neo_class_node_form

//to control the form opertion we can check 

/**
 * Implementation of hook_init().
 */
function neologism_init() {
  drupal_add_css(drupal_get_path('module', NEOLOGISM) .'/neologism.css');
  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/neologism.js');
  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/neologism.termstree.js');

  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/evocfields/superclass.widgetbehaviour.js');
  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/evocfields/disjointwith.widgetbehaviour.js');
  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/evocfields/domain.widgetbehaviour.js');
  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/evocfields/range.widgetbehaviour.js');
  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/evocfields/superproperty.widgetbehaviour.js');
  drupal_add_js(drupal_get_path('module', 'neologism') . '/js/evocfields/inverse.widgetbehaviour.js');
  
  //drupal_add_css( drupal_get_path('module', NEOLOGISM) . '/ext/css/xtheme-darkgray.css');
  //drupal_add_css( drupal_get_path('module', NEOLOGISM) . '/ext/css/xtheme-slickness.css');
  //drupal_add_css( drupal_get_path('module', NEOLOGISM) . '/ext/css/xtheme-olive.css');
  
  //drupal_add_css(drupal_get_path('module', NEOLOGISM) .'/js/jquery-treeview/jquery.treeview.css');
  //drupal_add_js(drupal_get_path('module', 'neologism') . '/js/jquery-treeview/jquery.cookie.js');
  //drupal_add_js(drupal_get_path('module', 'neologism') . '/js/jquery-treeview/jquery.treeview.js');
}

/**
 * Implementation of hook_perm().
 */
function neologism_perm() {
    return array(
    	PERMISSION_EDIT_VOCABULARIES, 
    	PERMISSION_IMPORT_VOCABULARIES,
 //   	PERMISSION_NEOLOGISM_ACCESS
    );
}

/**
 * Implementation of hook_theme().
 */
function neologism_theme() {
  return array(
    'class_view' => array(
      'arguments' => array('node' => array(), 'teaser' => NULL, 'page' => NULL, 'links' => NULL)
    ),
    
    'property_view' => array(
      'arguments' => array('node' => array(), 'teaser' => NULL, 'page' => NULL, 'links' => NULL)
    ),
    
    'neologism_item_list' => array(
      'arguments' => array('items' => array(), 'title' => NULL, 'type' => 'ul', 'attribute' => NULL),
    ),
    NEOLOGISM_VOCABULARY_FORM_ID => array(
    	'arguments' => array('from' => NULL)
    ),
    NEOLOGISM_PROPERTY_FORM_ID => array(
    	'arguments' => array('from' => NULL)
    ),
    NEOLOGISM_CLASS_FORM_ID => array(
    	'arguments' => array('from' => NULL)
    ),
    'render_URI_field' => array(
    	'arguments' => array('element' => NULL)
    ),
    'neologism_form_element' => array(
    	'arguments' => array('element' => NULL, 'value' => NULL)
    ),
    'render_custom_namespace_field' => array(
    	'arguments' => array('element' => NULL)
    ),
    
  );
}

/**
 * This function build the breadcrumb for neologism
 * @param $path
 * @param $title
 * @return unknown_type
 */
function _neologism_build_breadcrumb($path, $title = NULL) {
	$breadcrumb = array('<a href="'.base_path().'">Home</a>');
	if( $path ) {
		$breadcrumb[] = '<a href="'.base_path().$path.'">'.(($title == NULL) ? $path : $title).'</a>';
	}
	return $breadcrumb;
}

/**
 * This function handler all the content negotiation. If the page to show is an xHTML page we need
 * to know what kind of node it is. If it is a node different from NEOLOGISM_CT_VOCABULARY we use
 * the node_view() function to render it.
 * @param $node
 * @return unknown_type
 */
function neologism_export_conneg($node) {
	
	if( $node->type == NEOLOGISM_CT_VOCABULARY ) {
		$request_uri = $_SERVER["REQUEST_URI"];
	  $accept = $_SERVER["HTTP_ACCEPT"];
	  $redirect_uri = neologism_get_preferred_uri($request_uri, $accept);
	  header("Vary: Accept");
	  header("Content-Location: " . $redirect_uri);
	  $preferred_variant = neologism_get_preferred_content($accept);
	  if ($preferred_variant == HTML) {
	    return neologism_export_html($node);	
	  } else if ($preferred_variant == RDF) {
	    neologism_export_rdfxml($node);
	  } else if ($preferred_variant == N3) {
	    neologism_export_n3($node);
	  } else if ($preferred_variant == XML) {
	    neologism_export_xml($node);
	  } else {
	    drupal_set_message("Shouldn't happen! preferred variant was $preferred_variant in neologism_export_conneg()");
	  }
	}
	else if( $node->type == NEOLOGISM_CT_CLASS ) {
		drupal_set_breadcrumb(_neologism_build_breadcrumb($node->vocabulary->path, $node->vocabulary->title));
		drupal_set_title($node->vocabulary->title.':'.$node->title);
		return theme('class_view', $node, FALSE, FALSE, FALSE);
	}
	else if( $node->type == NEOLOGISM_CT_PROPERTY ) {
		drupal_set_breadcrumb(_neologism_build_breadcrumb($node->vocabulary->path, $node->vocabulary->title));
		drupal_set_title($node->vocabulary->title.':'.$node->title);
		return theme('property_view', $node, FALSE, FALSE, FALSE);
	}
	else {
		drupal_set_breadcrumb(_neologism_build_breadcrumb($node->path, $node->title));	
		drupal_set_title($node->title);
		return theme('node', $node, FALSE, TRUE, FALSE);	
	}
}

/**
 * Implementation of hook_menu().
 */
function neologism_menu() {
  $items = array();
  
  $items['node/%neologism_vocabulary'] = array(
      'title' => 'View',
      'page callback' => 'neologism_export_conneg',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_LOCAL_TASK,
  );

  $items['node/%neologism_vocabulary/'.RDF] = array(
      'title' => 'View RDF/XML',
      'page callback' => 'neologism_export_rdfxml',
  		'page arguments' => array(1),
     	'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['node/%neologism_vocabulary/'.N3] = array(
      'title' => 'View N3',
      'page callback' => 'neologism_export_n3',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['node/%neologism_vocabulary/'.XML] = array(
      'title' => 'View XML',
      'page callback' => 'neologism_export_xml',
  		'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['node/%neologism_vocabulary/'.LAYOUT] = array(
      'title' => 'Diagram Layout',
      'page callback' => 'neologism_diagram_layout',
      'page arguments' => array(1),
      'access callback' => 'node_access',
      'access arguments' => array('view', 1),
      'type' => MENU_CALLBACK,
  );
  $items['neologism/import'] = array(
    'title' => 'Import vocabulary',
    'description' => 'Import an existing RDF vocabulary from the Web or from an RDF file for editing.',
    'page callback' => 'neologism_import_form_callback',
    'access arguments' => array(PERMISSION_IMPORT_VOCABULARIES),
    'file' => 'neologism.import.inc',
    'weight' => 5,
  );
  // ajax/json gateway for preview classes and properties
  $items['neologism/json/classestree'] = array(
    'title' => 'Neologism AJAX gateway',
    'description' => 'Neologism Ajax Gateway.',
    'page callback' => 'neologism_gateway_get_classes_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );
  $items['neologism/json/objectpropertytree'] = array(
    'title' => 'Neologism AJAX gateway',
    'description' => 'Neologism Ajax Gateway.',
    'page callback' => 'neologism_gateway_get_properties_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );
  
  $items['neologism/json/fulltree'] = array(
    'title' => 'Neologism AJAX gateway - get full classes tree structure',
    'description' => 'Get full tree for all the current classes stored in Neologism.',
    'page callback' => 'neologism_gateway_get_full_classes_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );
  
  $items['neologism/json/propertiesfulltree'] = array(
    'title' => 'Neologism AJAX gateway - get full properties tree structure',
    'description' => 'Get get full properties tree structure stored in Neologism.',
    'page callback' => 'neologism_gateway_get_full_properties_tree',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'neologism.gateway.php'
  );

  return $items;
}

/**
 * Implementation of hook_form_alter().
 */
function neologism_form_alter(&$form, &$form_state, $form_id) {
	if ( $form_id == NEOLOGISM_VOCABULARY_FORM_ID ) {
    // add validation function for create or edition of properties form
		$form['#validate'][] = 'neo_vocabulary_node_form_validate';
  	$form['title']['#theme'] = "render_URI_field";
  	
  	$default_namespace = url('', array('absolute' => TRUE));
  	$form['title']['#namespace'] = $default_namespace; 
  	// fix the size of the Id field to 20
  	$form['title']['#size'] = 20;
  	$form['#attributes'] = array('onreset' => 'Neologism.neoVocabularyFormOnLoad()', 'onsubmit' => 'Neologism.neoVocabularyFormOnSubmit()');
  	
  	// add the group for ranges
	  /*
  	$form['namespace_group']['namespace_type'] = array(
	    '#type' => 'radios',
	    //'#title' => t('The value of this property is'),
	    '#title' => t('Namespace URI'),
	    '#options' => array(
	    	1 => t('Default ('.$default_namespace.')'),
	    	2 => t('Custom')
	    ),
	    //'#description' => t('Description should goes here....'),
	    '#default_value' => 1,
	    '#prefix' => '<div id="range-group-resourcetype">',
	    '#suffix' => '</div>',
	    '#attributes' => array('onClick' => 'Neologism.checkResourceType()'),
	    //'#theme' => "render_custom_namespace_field"
	  );
	  */
  	
  	// create a fieldset and make a copy of the field_additional_custom_rdf to locate it in a collapsable 
  	// panel and unset it for the current position
  	$form['aditional_custom_rdf_fieldset'] = array(
	    '#type' => 'fieldset', 
	    '#title' => t('Additional custom RDF'), 
	    '#collapsible' => TRUE, 
	    '#collapsed' => TRUE,
  		'#description' => t('Here you can provide additional RDF statements that will be included in the RDF description of the vocabulary. Statements must be provided in N3 syntax.')
  	);
  	$form['aditional_custom_rdf_fieldset']['field_additional_custom_rdf'] = $form['field_additional_custom_rdf'];
  	unset($form['field_additional_custom_rdf']);
  	
	  $form['field_custom_namespace']['#theme'] = 'render_custom_namespace_field';
	  $form['field_custom_namespace']['#default_namespace'] = $default_namespace.$form['title']['#default_value'];
	  
  	// we never use the preview button
		unset($form['buttons']['preview']);
  	unset($form['menu']);
  	// hide the path fielset
  	$form['path']['#access'] = FALSE;
  	
  	// add to the title label a description
  	$form['title']['#description'] = 'Only letters, numbers, dashes, and underscores.';
		
  	// Hide the layout field of the vocublary page since it's only used
	  // internally by the viewer to store the diagram layout.
	  if (isset($form['field_layout'])) {
	    unset($form['field_layout']);
	  }
	  // Collapse the URL path fieldset to prevent people from messing with it.
	  if (isset($form['path']['#collapsed'])) {
	    $form['path']['#collapsed'] = TRUE;
	  }
	}
    
  if( $form_id == NEOLOGISM_PROPERTY_FORM_ID ) {
  	// hide the field
	  $form['field_vocabulary']['#access'] = FALSE;
	  
  	$form['title']['#theme'] = "render_URI_field";
  	$form['title']['#size'] = 20;
		
  	// we never use the preview button neither the menu fieldset
		unset($form['buttons']['preview']);
  	unset($form['menu']);
  	// hide the path fielset
  	$form['path']['#access'] = FALSE;
  	$form['#validate'][] = 'neo_property_node_form_validate';
    $form['buttons']['submit']['#submit'][] = '_neo_property_node_form_submit';
    
    // add behaviours for evoc fields if they are using the MXCheckBox selection widget
    $form['field_domain2']['#mxcbs_behaviour']['owntitle'] = FALSE;
    $form['field_domain2']['#mxcbs_behaviour']['handler'] = 'Neologism.createDomainSelecctionWidget';
    $form['field_domain2']['#mxcbs_behaviour']['url_gateway'] = 'neologism/json/fulltree';
    $form['field_domain2']['#weight'] = 1;
    
    $form['field_range2']['#mxcbs_behaviour']['owntitle'] = TRUE;
    $form['field_range2']['#mxcbs_behaviour']['handler'] = 'Neologism.createRangeSelecctionWidget';
    $form['field_range2']['#mxcbs_behaviour']['url_gateway'] = 'neologism/json/fulltree';
    $form['field_range2']['#prefix'] = '<div id="range-treeview">';
    $form['field_range2']['#suffix'] = '</div>';
    $form['field_range2']['#weight'] = 2;
    
    // add behaviours for evoc fields if they are using the MXCheckBox selection widget
    $form['field_superproperty2']['#mxcbs_behaviour']['owntitle'] = FALSE;
    $form['field_superproperty2']['#mxcbs_behaviour']['handler'] = 'Neologism.createSuperpropertySelecctionWidget';
    $form['field_superproperty2']['#mxcbs_behaviour']['url_gateway'] = 'neologism/json/propertiesfulltree';
    $form['field_range2']['#weight'] = 3;
    
    // add behaviours for field_inverse2 field
    $form['field_inverse2']['#mxcbs_behaviour']['owntitle'] = FALSE;
    $form['field_inverse2']['#mxcbs_behaviour']['handler'] = 'Neologism.createInverseSelecctionWidget';
    $form['field_inverse2']['#mxcbs_behaviour']['url_gateway'] = 'neologism/json/propertiesfulltree';
    $form['field_inverse2']['#prefix'] = '<div id="inverse-treeview">';
	  $form['field_inverse2']['#suffix'] = '</div>';
	  $form['field_range2']['#weight'] = 4;
    
    // add to the title label a description
  	$form['title']['#description'] = 'Only letters, numbers, dashes, and underscores.';
  	
	  // add the group for ranges
	  $form['range_group']['resource_type'] = array(
	    '#type' => 'radios',
	    //'#title' => t('The value of this property is'),
	    '#title' => t('Range'),
	    '#options' => array(
	    	1 => t('The value of this property is another resource.'),
	    	2 => t('The value of this property is a literal (string, number, date, ...).'),
	    	3 => t('The value of this property can be either.')
	    ),
	    //'#description' => t('Description should goes here....'),
	    '#default_value' => 1,
	    '#prefix' => '<div id="range-group-resourcetype">',
	    '#suffix' => '</div>',
	    '#attributes' => array('onClick' => 'Neologism.checkResourceType()'),
	    //'#theme' => "render_URI_field"
	  );
	  
	  $form['range_group']['data_types'] = array(
	  	'#title' => '',//t('Data Types'),
	  	'#type' => 'select',
	  	'#description' => t('Select the data type for this property.'),
	  	'#options' => neologism_get_xsd_datatype_list(),
	  	'#multiple' => FALSE,
	  	'#prefix' => '<div id="range-group-datatypes">',
	  	'#suffix' => '</div>'
	  	//'#weight' => 20
	  );
	 
	  // Set the size of the description field to 5 rows in class and property forms.
	  if (isset($form['body_field']['body']['#rows'])) {
	    $form['body_field']['body']['#rows'] = 4;
	  }
  	
	  if ( isset($_GET['v']) && isset($form['field_vocabulary']['#default_value']) ) {
	    $vocabulary_id = (int)$_GET['v'];
	    $form['field_vocabulary']['#default_value'][0]['nid'] = $vocabulary_id;
	    
	    // this method is wonderful but slower 
	    $current_voc = node_load($vocabulary_id);
	    // so we need to decide a direct query execution
	    //$current_voc = db_fetch_object(db_query(db_rewrite_sql("SELECT n.title, c.field_custom_namespace_value FROM {node} n INNER JOIN {content_type_neo_vocabulary} c ON n.nid = c.nid WHERE n.nid = %d AND n.type = '%s'"), 
	    //	$vocabulary_id, NEOLOGISM_CT_VOCABULARY));
			if( $current_voc ) {
				$form['title']['#namespace'] = _neologism_get_namespace_uri($current_voc);
				$form['holder'] = array(
	    		'#type' => 'value',
	    		'#value' => array('vocabulary_title' => $current_voc->title, 'operation' => 'create')		
	    	);
	    	
	    	//add a Cancel button
			  $form['buttons']['cancel'] = array(
			  	'#type' => 'button',
			  	'#value' => t('Cancel'),
			  	'#weight' => 20,
			  	'#attributes' => array('onclick' => 'window.location = \''.base_path().$current_voc->title.'/\'; return false;'),
			  );
			}
	  }
	  else if( arg(2) == 'edit' && isset($form['#node']) ) {
    	// add validation function for create or edition of properties form
      $current_voc = NULL;
	  	if( !isset($form['#node']->vocabulary) ) {
		  	$vocabulary_id = $form['#node']->field_vocabulary[0]['nid']; // there is different way to get this value
	    	$current_voc = node_load($vocabulary_id);
      }
      else {
      	$current_voc = $form['#node']->vocabulary;
      }
      
    	if( $current_voc ) {
	      $qname = $current_voc->title.':'.$form['#node']->title; // create the qname for the property
	      
				$form['title']['#namespace'] = _neologism_get_namespace_uri($current_voc);
				// create the holder with the values that we need to process/render the form
	      $form['holder'] = array(
	    		'#type' => 'value',
	    		'#value' => array('vocabulary_title' => $current_voc->title, 'operation' => 'edit', 'qname' => $qname)		
	    	);
	      // why need to inform to the widget that there is comming an edition for a value, so the widget can
	      // handle the situation.
	      $form['field_domain2']['#mxcbs_behaviour']['editing_value'] = $qname;
	      $form['field_range2']['#mxcbs_behaviour']['editing_value'] = $qname;
	      $form['field_superproperty2']['#mxcbs_behaviour']['editing_value'] = $qname;
	      $form['field_inverse2']['#mxcbs_behaviour']['editing_value'] = $qname;
			}

			// set the default value depending of the current property range value
    	$range = $form['#node']->field_range2[0]['evoc_term'];
    	if( isset($range) && _neologism_is_xsd_datatype($range) ) {
	    	$form['range_group']['data_types']['#default_value'] = $range;
	    	// set the radio button to The value of this property is a literal (string, number, date, ...).
	    	$form['range_group']['resource_type']['#default_value'] = 2;
    	}
    }
    else if( arg(3) == 'parent' ) { // Select the parent class if provided in the url of type node/add/property/parent/11
    	$node_property = node_load(arg(4));
    	// we can use node_load($nclass->field_vocabulary[0]['nid']) but gain speed just execute the following query
      $current_voc = node_load($node_property->field_vocabulary[0]['nid']);
    	if ( $current_voc ) {
	      $qname = $current_voc->title.':'.$node_property->title;
	      
	      $form['title']['#namespace'] = _neologism_get_namespace_uri($current_voc);
	    	// create the holder with the values that we need to process/render the form
	      $form['holder'] = array(
	    		'#type' => 'value',
	    		'#value' => array('vocabulary_title' => $current_voc->title, 'operation' => 'create')		
	    	);
	      	
	      // extra_values is an optional parameter for #mxcbs_behaviour attribute that contain extra default values for the widget tree
	    	$form['field_superproperty2']['#mxcbs_behaviour']['extra_values'] = array($qname);
	    	$form['field_superproperty2']['#mxcbs_behaviour']['execute_preprocess'] = TRUE;
	    	
	    	// fill the field with thw default value
	      $form['field_vocabulary']['#default_value'][0]['nid'] = $current_voc->field_vocabulary[0]['nid'];
    	}
    }
  }
  
  // add the validation handler to both content type
  if( $form_id == NEOLOGISM_CLASS_FORM_ID )
  {
  	// hide the field
	  $form['field_vocabulary']['#access'] = FALSE;
	  
  	// we never use the preview button neither the menu fieldset
		unset($form['buttons']['preview']);
  	unset($form['menu']);
  	// hide the path fielset
  	$form['path']['#access'] = FALSE;
  	
  	$form['title']['#theme'] = "render_URI_field";
  	$form['title']['#size'] = 20;
  	
  	$form['#validate'][] = 'neo_class_node_form_validate';
  	//$form['#redirect'] = 'node/'.$form['#node']->field_vocabulary[0]['nid'];
    $form['buttons']['submit']['#submit'][] = '_neo_class_node_form_submit';
  	
    $form['field_superclass2']['#mxcbs_behaviour']['owntitle'] = FALSE;
    $form['field_superclass2']['#mxcbs_behaviour']['handler'] = 'Neologism.createSuperclassSelecctionWidget';
    $form['field_superclass2']['#mxcbs_behaviour']['url_gateway'] = 'neologism/json/fulltree';
    $form['field_disjointwith2']['#mxcbs_behaviour']['owntitle'] = FALSE;
    $form['field_disjointwith2']['#mxcbs_behaviour']['handler'] = 'Neologism.createDisjointwithSelecctionWidget'; 
    $form['field_disjointwith2']['#mxcbs_behaviour']['url_gateway'] = 'neologism/json/fulltree'; 
  
    // hide the input field
    $form['field_vocabulary']['#access'] = FALSE;
    
    // add to the title label a description
  	$form['title']['#description'] = 'Only letters, numbers, dashes, and underscores.';
  	
  	// Set the size of the description field to 5 rows in class and property forms.
	  if (isset($form['body_field']['body']['#rows'])) {
	    $form['body_field']['body']['#rows'] = 4;
	  }
    
	  if ( isset($_GET['v']) && isset($form['field_vocabulary']['#default_value']) ) {
	    $vocabulary_id = (int)$_GET['v'];
	    $form['field_vocabulary']['#default_value'][0]['nid'] = $vocabulary_id;
	    
	    $current_voc = node_load($vocabulary_id);
			if( $current_voc ) {
				$form['title']['#namespace'] = _neologism_get_namespace_uri($current_voc);
				$form['holder'] = array(
	    		'#type' => 'value',
	    		'#value' => array('vocabulary_title' => $current_voc->title, 'operation' => 'create')		
	    	);
			}
			
			//add a Cancel button
		  $form['buttons']['cancel'] = array(
		  	'#type' => 'button',
		  	'#value' => t('Cancel'),
		  	'#weight' => 20,
		  	'#attributes' => array('onclick' => 'window.location = \''.base_path().$current_voc->title.'/\'; return false;'),
		  );
	  }
	  else if( arg(2) == 'edit' && isset($form['#node']) ) {
	  	$current_voc = NULL;
	  	if( !isset($form['#node']->vocabulary) ) {
		  	$vocabulary_id = $form['#node']->field_vocabulary[0]['nid']; // there is different way to get this value
	    	$current_voc = node_load($vocabulary_id);
      }
      else {
      	$current_voc = $form['#node']->vocabulary;
      }
      	
    	if( $current_voc ) {
	      $qname = $current_voc->title.':'.$form['#node']->title; // create the qname for the property
	      
				$form['title']['#namespace'] = _neologism_get_namespace_uri($current_voc);
				// create the holder with the values that we need to process/render the form
	      $form['holder'] = array(
	    		'#type' => 'value',
	    		'#value' => array('vocabulary_title' => $current_voc->title, 'operation' => 'edit', 'qname' => $qname)		
	    	);
	      // why need to inform to the widget that there is comming an edition for a value, so the widget can
	      // handle the situation.
	      $form['field_superclass2']['#mxcbs_behaviour']['editing_value'] = $qname;
	      $form['field_disjointwith2']['#mxcbs_behaviour']['editing_value'] = $qname;
    	}
    }
    // the user has click over the "Create new subclass" link
    // Select the parent class if provided in the url of type node/add/class/parent/9
    else if( arg(3) == 'parent' ) {
    	$node_class = node_load(arg(4));
      $current_voc = node_load($node_class->field_vocabulary[0]['nid']);
      if( $current_voc ) {
	    	$qname = $current_voc->title.':'.$node_class->title;
	      
	      $form['title']['#namespace'] = _neologism_get_namespace_uri($current_voc);
	    	// create the holder with the values that we need to process/render the form
	      $form['holder'] = array(
	    		'#type' => 'value',
	    		'#value' => array('vocabulary_title' => $current_voc->title, 'operation' => 'create')		
	    	);
	    	
	      // fill the field with thw default value
	      $form['field_vocabulary']['#default_value'][0]['nid'] = $node_class->field_vocabulary[0]['nid'];
	      
	     	// extra_values is an optional parameter for #mxcbs_behaviour attribute that contain extra default values for the widget tree
	    	$form['field_superclass2']['#mxcbs_behaviour']['extra_values'] = array($qname);
	    	$form['field_superclass2']['#mxcbs_behaviour']['execute_preprocess'] = TRUE;
      }
  	}
  }
}

function neologism_vocabulary_load($nid) {
  if ($nid) {
    $node = node_load($nid);
    return $node;
  }
  else {
    return FALSE;
  }
}

/**
 * Output the HTML version of the vocabulary specified as input.
 */
function neologism_export_html($node) {
  // TODO: finish to clean all the old code using the $node variable by the $vocabulary
	$vocabulary_title = check_plain($node->field_title[0]['value']);
	$vocabulary = new stdClass();
	$vocabulary->id = $node->title;
  $vocabulary->title = $node->field_title[0]['value'];
  $vocabulary->description = $node->body;
  $vocabulary->authors = $node->field_authors;
  
  $output = '<div id="vocabulary-view">';
  
  $image = theme('image', drupal_get_path('module', 'neologism') .'/images/icons/rdf_w3c_icon.48.gif', t('RDF/XML version of this vocabulary.'), t('RDF/XML version of this vocabulary.'));
  $link = l($image, $node->path.'.'.RDF, array('html' => TRUE, 'attributes' => Array('class' => 'icon')));
  $image = theme('image', drupal_get_path('module', 'neologism') .'/images/icons/n3.gif', t('N3/Turtle version of this vocabulary.'), t('N3/Turtle version of this vocabulary.'));
  $link2 = l($image, $node->path.'.'.N3, array('html' => TRUE, 'attributes' => Array('class' => 'icon')));
  $output .= '<div id="icons">'.$link.'&nbsp;'.$link2.'</div>';
  
  //$output .= '<h1>'.$vocabulary_title.'</h1>';
    
  // clear the title so we can print our formatted title
  drupal_set_breadcrumb(_neologism_build_breadcrumb($node->path, $node->title));
  drupal_set_title($vocabulary_title);
  
  $classes = _neologism_get_all_classes($node);
  usort($classes, '_neologism_cmp_2array_alphabetically');
  $properties = _neologism_get_all_properties($node);
  usort($properties, '_neologism_cmp_2array_alphabetically');
  
  $output .= '<div id="last-update" ><h3>Last update:</h3><div id="last-update-value">'.format_date($node->changed, 'large').'</div></div>';
  
  $output .= '<div id="authors" ><h3>'.t('Author').':</h3>';
  foreach($node->field_authors as $author) {
    $author = user_load($author);
    $output .= '<div id="author-value">';
    $name = empty($author->profile_neologism_fullname) ? $author->name : $author->profile_neologism_fullname;
    if ($author->profile_neologism_homepage) {
      $output .= l($name, $author->profile_neologism_homepage);
    } else {
      $output .= $name;
    }
    if ($author->profile_neologism_affiliation) {
      if ($author->profile_neologism_affiliation_homepage) {
        $output .= ' (' . l($author->profile_neologism_affiliation, $author->profile_neologism_affiliation_homepage) . ')';
      } else {
        $output .= ' (' . $author->profile_neologism_affiliation . ')';
      }
    }
    if ($author->profile_neologism_show_email) {
      $output .= ' <i>(' . l('Email', 'mailto:' . $author->mail) . ')</i>';
    }
    $output .= '</div>';
  }
  $output .= '</div>';

  $namespace_url = _neologism_get_namespace_uri($node);
  $output .= '<div id="namespace"><h3>Namespace URI:</h3> <div id="namespace-value">'.$namespace_url.'</div></div>';

  // Abstract
  $output .= '<div id="abstract" class="neologism field"><div class="block title"><h3>Abstract&nbsp;</h3></div> ' . $node->field_abstract[0]['value'] . ' </div>';

  // Content type in urls are with - instead of _
  $vocabulary_url_str = str_replace('_', '-', NEOLOGISM_CT_VOCABULARY);
  $class_url_str = str_replace('_', '-', NEOLOGISM_CT_CLASS);
  $property_url_str = str_replace('_', '-', NEOLOGISM_CT_PROPERTY);
  
  //Vocabulary at glance
  //$output .= '<h2 id="sec_glance" class="neologism">'.$vocabulary_title.' at a glance</h2>';
  $output .= '<h2 id="sec_glance" class="neologism">All terms at a glance</h2>';
  if ($classes || $properties) {
    $output .= '<div id="atglance">';
  }
  
  // TODO: loop through the classes and properties and populate the atglance and complete reference
  // the current fashion is not optimized as we need to read each class/prop twice
  // Display the Classes
  if ($classes) {
    $output .= '<p><strong>Classes:</strong> ';
    $count = 0; 
    foreach ($classes as $class) {
      if( $count > 0 ) 
        $output .= ' | ';
      $output .= '<a href="#' . $class['id'] . '" title="class ' . check_plain($node->title) . ':'. check_plain($class['id']) . '">' . check_plain($class['id']) . '</a>';
      $count++;
    }
    $output .= '</p>';
  }

  // Display the Properties
  if ($properties) {
    $output .= $classes ? '<br/>' : ''; 
    $output .= '<p><strong>Properties:</strong> ';
    $count = 0;
    foreach ($properties as $property) {
      if( $count > 0 ) { 
          $output .= ' | ';
      }
      $output .= '<a href="#' . $property['id'] . '" title="property ' . check_plain($node->title) . ':'. check_plain($property['id']) . '">' . check_plain($property['id']) . '</a>';
      $count++;
    }
    $output .= '</p>';
  }
  
  if ($classes || $properties) {
    $output .= '</div>';
  }
  
  // add the links for add classes or properties if there is right 
  if (user_access(PERMISSION_EDIT_VOCABULARIES)) {
		$add_newclass_link = l('Create new class', 'node/add/'.$class_url_str, array('query' => 'v='.$node->nid, 'attributes' => Array('title' => 'Create a new class for '.$vocabulary_title)));
		$add_newproperty_link = l('Create new property', 'node/add/'.$property_url_str, array('query' => 'v='.$node->nid, 'attributes' => Array('title' => 'Create a new property for '.$vocabulary_title)));
    $output .= '<p id="add_terms_link" class="neologism">'.$add_newclass_link.'| '.$add_newproperty_link.'</p>';
  }
  
  //ext_load_library();
  drupal_add_js( array('neologism' => array('voc_id' => $node->nid, 'voc_title' => $node->title)), 'setting');
  
  if ($classes) {
    $output .= '<div id="class-tree" ></div>';
    
    $opts = array('absolute' => TRUE);
    $json_url = url('neologism/json/classestree', $opts);
      
    //create the variable into the namespace neologism
    // eg: Drupal.settings.neologism.json_url
    drupal_add_js( array('neologism' => array('json_url' => $json_url)), 'setting');
    drupal_add_js( drupal_get_path('module', NEOLOGISM) . '/js/class_treeview.js');
  }
  
  if ($properties) {
    // object property hierarchy tree
    $output .= '<div id="object-property-tree" ></div>';
    
    $opts = array('absolute' => TRUE);
    $json_url = url('neologism/json/objectpropertytree', $opts);
    drupal_add_js( array('neologism' => array('property_json_url' => $json_url)), 'setting');
    drupal_add_js( drupal_get_path('module', NEOLOGISM) . '/js/object_property_treeview.js');
  }
  
  //drupal_add_css( drupal_get_path('module', NEOLOGISM) . '/ext/css/xtheme-darkgray.css');
  //drupal_add_css( drupal_get_path('module', NEOLOGISM) . '/ext/css/xtheme-slickness.css');
  
  // embend the diagram
  $output .= '';
  
  $base = base_path();
  $swf = $base . drupal_get_path('module','neologism').'/includes/Diagram.swf';
  $img_legend = $base . drupal_get_path('module','neologism').'/includes/legend.png';
  $edit_mode = user_access(PERMISSION_EDIT_VOCABULARIES);
  $prefix = $base.$node->path;
  $token = drupal_get_token();
  $width = '100%';
  $height = '600px';
  
  $flex_params = "editMode=$edit_mode&prefix=$prefix&token=$token";
  $output .= '
    <div id="diagram">
    <h2>Overview diagram</h2>
    <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        id="Diagram" width="'.$width.'" height="'.$height.'"
        codebase="http://fpdownload.macromedia.com/get/flashplayer/current/swflash.cab">
            <param name="movie" value="'.$swf.'" />
            <param name="quality" value="high" />
            <param name="bgcolor" value="#ffffff" />
            <param name="flashVars" value="'.$flex_params.'" />
            <param name="allowScriptAccess" value="sameDomain" />
            <embed src="'.$swf.'" quality="high" bgcolor="#ffffff"
                width="'.$width.'"
                height="'.$height.'"
                name="Diagram"
                align="middle"
                play="true"
                loop="false"
                quality="high"
                allowScriptAccess="sameDomain"
                type="application/x-shockwave-flash"
                pluginspage="http://www.adobe.com/go/getflashplayer"
                flashVars="'.$flex_params.'">
            </embed>
    </object>
  </div>';
  
  // insert the vocabulary's dscription
  $output .= '<div id="description">'.$node->body.'</div>';

  //Display complete reference
  if ($classes) {
    $output .= '<h2 id="sec_reference" class="neologism">' . $vocabulary_title . ' Classes</h2>';
    foreach ($classes as $class) {
      $output .= theme('class_view', node_load($class['nid']), TRUE );
      //  $output .= node_view(node_load($class['nid']), 1, $vocabulary_title);
    }
  }
   
  if ($properties) {
    $output .= '<h2 id="sec_reference" class="neologism">' . $vocabulary_title . ' Properties</h2>';
    foreach ($properties as $property) {
        //$output .= theme('neo_property_node_view', node_load($property['nid']), 1, $node->title);
        $output .= theme('property_view', node_load($property['nid']), TRUE );
    }
  }
  
  $output .= theme('pager', NULL, variable_get('default_nodes_main', 10));
 
  $output .= '</div>';
  
  return $output;
}

/**
 * Output the RDF model of the vocabulary specified as input
 * using RAP (RDF API for PHP)
 * seeAlso http://www4.wiwiss.fu-berlin.de/bizer/rdfapi/
 */
function &neologism_get_rdf_model($node) {
  $required_namespaces = array($node->title, 'rdf', 'rdfs', 'dc', 'owl', 'foaf', 'vann');
  $classes = _neologism_get_all_classes($node, $required_namespaces);
  $properties = _neologism_get_all_properties($node, $required_namespaces);
  
  $namespace = _neologism_get_namespace_uri($node);

  // Set up model with all necessary namespaces
  $namespaces = rdf_get_namespaces();
  $rdf = new neologism_rdf_writer();
  foreach ($required_namespaces as $prefix) {
    $ns = $namespaces[$prefix];
    if (is_array($ns)) {
      $ns = $ns[0];
    }
    $rdf->register_namespace($prefix, $ns);
  }
    
  // export the ontology
  $doc = url($node->path, array('absolute' => true));
  $rdf->triple_qname($doc, "rdf:type", 'foaf:Document');
  $rdf->triple_qname($doc, "rdf:type", 'owl:Ontology');
  $rdf->triple_literal($doc, "dc:title", $node->field_title[0]['value']);
  $rdf->triple_literal($doc, "dc:description", $node->field_abstract[0]['value']);
  $rdf->triple_literal($doc, "vann:preferredNamespaceUri", $namespace);
  $rdf->triple_literal($doc, "vann:preferredNamespacePrefix", $node->title);
  
  // authors and affiliations
  foreach ($node->field_authors as $uid) {
    $author = user_load($uid);
    $person = $doc . '#' . rawurlencode($author->name);
    $rdf->triple_uri($doc, "dc:creator", $person);
    $rdf->triple_qname($person, "rdf:type", 'foaf:Person');
    if ($author->profile_neologism_fullname) {
      $rdf->triple_literal($person, "foaf:name", $author->profile_neologism_fullname);
    } else {
      $rdf->triple_literal($person, "foaf:nick", $author->name);
    }
    $rdf->triple_uri($person, "foaf:homepage", $author->profile_neologism_homepage);
    if ($author->profile_neologism_show_email) {
      $rdf->triple_uri($person, "foaf:mbox", "mailto:" . $author->mail);
    }
    if ($author->profile_neologism_affiliation) {
      $org = $doc . '#' . rawurlencode($author->profile_neologism_affiliation);
      $rdf->triple_qname($org, 'rdf:type', 'foaf:Organization');
      $rdf->triple_uri($org, 'foaf:member', $person);
      $rdf->triple_literal($org, 'foaf:name', $author->profile_neologism_affiliation);
      $rdf->triple_uri($org, 'foaf:homepage', $author->profile_neologism_affiliation_homepage);
    }
  }

  // classes
  foreach ($classes as $class) {
    $class_uri = $namespace . $class["id"];
    $rdf->triple_qname($class_uri, "rdf:type", 'rdfs:Class');
    $rdf->triple_uri($class_uri, "rdfs:isDefinedBy", $doc);
    $rdf->triple_literal($class_uri, "rdfs:label", $class["label"]);
    $rdf->triple_literal($class_uri, "rdfs:comment", $class["comment"]);
    $rdf->triples_qname($class_uri, "rdfs:subClassOf", $class[SUPERCLASSES]);
    $rdf->triples_qname($class_uri, "owl:disjointWith", $class[DISJOINTS_WITH]);
  }
 
  // export all properties
  foreach ($properties as $property) {
    $property_uri = $namespace . $property["id"];
    $rdf->triple_qname($property_uri, "rdf:type", 'rdf:Property');
    $rdf->triple_uri($property_uri, "rdfs:isDefinedBy", $doc);
    $rdf->triple_literal($property_uri, "rdfs:label", $property["label"]);
    $rdf->triple_literal($property_uri, "rdfs:comment", $property["comment"]);
    $rdf->triples_qname($property_uri, 'rdfs:domain', $property[DOMAINS]);
    $rdf->triples_qname($property_uri, 'rdfs:range', $property[RANGES]);
    $rdf->triples_qname($property_uri, 'rdfs:subPropertyOf', $property[SUBPROPERTYOF]);
    if (!empty($property['isInverseFunctional'])) {
      $rdf->triple_qname($property_uri, 'rdf:type', 'owl:InverseFunctionalProperty');
    }
    if (!empty($property["isFunctional"])) {
      $rdf->triple_qname($property_uri, 'rdf:type', 'owl:FunctionalProperty');
    }
    if (!empty($property[INVERSE])) {
      $rdf->triple_qname($property_uri, 'owl:inverseOf', $property['inverse']);
    }
  }
  
  if( !empty($node->field_additional_custom_rdf) ) {
  	// TODO If the vocabulary's N3 or RDF/XML is viewed, and the custom RDF field is not empty, then the 
		// content of that field will be parsed with an N3 parser and loaded into the model that is used to 
		// generate the N3 or RDF/XML output. So the additional triples will show up when the model is 
		// rendered.
		// Add code to do such a thing here
  }
  
  
  return $rdf;
}

/**
 * Output the RDF/XML version of the vocabulary specified as input
 */
function neologism_export_rdfxml($node) {
    $rdf = neologism_get_rdf_model($node);
    $rdf->write_rdfxml();
}

/**
 * Output the N3 version of the vocabulary specified as input
 */
function neologism_export_n3($node) {
    $rdf = neologism_get_rdf_model($node);
    $rdf->write_n3();
}

/**
 * Output the XML version of the vocabulary specified as input
 * using simpleXML
 * seeAlso http://www.php.net/simplexml
 */
function neologism_export_xml($node) {

  $xml = simplexml_load_string('<vocabulary/>');
  $xml->addAttribute('id', $node->title);

  //export all classes
  $classes = _neologism_get_all_classes($node);
  $classes_node = $xml->addChild('classes');
  foreach ( $classes as $class ) {
    $classnode = $classes_node->addChild('Class');
    $classnode->addAttribute('id', $class['id']);
    $classnode->addChild('label', $class['label']);
    
    if( isset($class['comment']) )
    {
      // we are using check_plain() for comment to avoid the 
      // warning: SimpleXMLElement::addChild() [simplexmlelement.addchild]: 
      // unterminated entity reference bytes. Being abstract, physical parts of computer 
      // memory that encode a file are excluded from the concept. 
      // in ...\sites\all\modules\neologism\neologism.module on line 714.
      $classnode->addChild('comment', check_plain($class['comment']));  
    }
    
    if( isset($class[SUPERCLASSES]) ) {
      foreach( $class[SUPERCLASSES] as $value ) {
        $subclassof_node = $classnode->addChild('subClassOf');
        $subclassof_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($class[DISJOINTS_WITH]) ) {
      foreach( $class[DISJOINTS_WITH] as $value ) {
        $disjointwith_node = $classnode->addChild('disjointWith');
        $disjointwith_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($class['description']) ) {
      $classnode->addChild('description', $class['description']);  
    }
  }

  //export all properties
  $properties = _neologism_get_all_properties($node);
  $properties_node = $xml->addChild("properties");
  foreach ($properties as $property) {
    $propertynode = $properties_node->addChild('Property');
    $propertynode->addAttribute('id', $property['id']);
    $propertynode->addChild('label', $property['label']);
    $propertynode->addChild('comment', $property['comment']);
    if( isset($property[SUBPROPERTYOF]) ) {
      foreach( $property[SUBPROPERTYOF] as $value ) {
        $subpropertyof_node = $propertynode->addChild('subPropertyOf');
        $subpropertyof_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($property[DOMAINS]) ) {
      foreach( $property[DOMAINS] as $value ) {
        $domain_node = $propertynode->addChild('domain');
        $domain_node->addAttribute('resource', $value);
      }
    }
    
    if( isset($property[RANGES]) ) {
      foreach( $property[RANGES] as $value ) {
        $range_node = $propertynode->addChild('range');
        $range_node->addAttribute('resource', $value);
      }
    }
    
    //<rdf:type rdf:resource="http://www.w3.org/2002/07/owl#FunctionalProperty"/>
    if( !empty($property["isInverseFunctional"]) ) {
      $type_node = $propertynode->addChild('type');
      $type_node->addAttribute('resource', 'FunctionalProperty');
    }
    
    if( !empty($property["isFunctional"]) ) {
      $type_node = $propertynode->addChild('type');
      $type_node->addAttribute('resource', 'InverseFunctionalProperty');
    }
  }

  header("Content-Type: application/xml; charset=utf-8");
  echo $xml->asXml();
}

/**
 * Layout of the vocabulary using REST
 */
function neologism_diagram_layout($node) {
  $name = $node->title;
  if (isset($_POST['layout']) && drupal_valid_token($_POST['token'])) {
    //POST, so write layout
    $layout = $_POST['layout'];
    neologism_write_layout($node, $layout);
  } 
  else {
    //GET, so read it
    $layout = neologism_get_layout($node);
    if ($layout == NULL) {
      $layout = neologism_generate_layout($node);
    }
    
    header("Content-Type: application/xml; charset=utf-8");
    echo $layout;
  }
}

/**
 * Get layout of a vocabulary
 */
function neologism_get_layout($node) {
  $result = db_fetch_array(db_query("select field_layout_value from {content_type_".NEOLOGISM_CT_VOCABULARY."} where nid = %d", $node->nid));
  $layout = $result[field_layout_value];
  return $layout;
}

/**
 * Generate a random layout for this vocabulary
 */
function neologism_generate_layout($node) {
  $xml = simplexml_load_string('<layout/>');
  $classes = _neologism_get_all_classes($node);
  $y = 0;
  foreach ($classes as $oneclass) {
    //export all classes
    $y = $y + 50;
    $class = $xml->addChild("rdfclass");
    $class->addAttribute("name", $oneclass["title"]);
    $class->addAttribute("label", $oneclass["label"]);
    $class->addAttribute("x", "50");
    $class->addAttribute("y", $y);
    $class->addAttribute("width", "100");
    $class->addAttribute("height", "30");
  }
  return $xml->asXml();
}

/**
 * Write the layout of a vocabulary
 */
function neologism_write_layout($node, $layout) {
  db_query("update {content_type_".NEOLOGISM_CT_VOCABULARY."} set field_layout_value = '%s' where nid = %d", $layout, $node->nid);
  content_clear_type_cache();
}

/**
 * Read/write diagram image image
 */
function neologism_image($node) {
  $name = $node->title;
  $output = 'For the moment this feature is not available';
  return $output;
}

/**
 * Implementation of hook_link().
 */
function neologism_link($type, $node = NULL, $teaser = FALSE) {
    $links = array();
    $vocabulary_nid = $node->field_vocabulary[0]['nid'];
    $destination = "destination=". drupal_urlencode("node/$vocabulary_nid");

    // Content type in urls are with - instead of _
    $vocabulary_url_str = str_replace('_', '-', NEOLOGISM_CT_VOCABULARY);
    $class_url_str = str_replace('_', '-', NEOLOGISM_CT_CLASS);
    $property_url_str = str_replace('_', '-', NEOLOGISM_CT_PROPERTY);

    //if( $type == 'node' )
	if (user_access(PERMISSION_EDIT_VOCABULARIES) && $node->type == NEOLOGISM_CT_CLASS) {
      $links['neologism_edit_class'] = array(
        'title' => t('Edit'),
        'href' => "node/$node->nid/edit",
        'query' => $destination,
	    'attributes' => array('title' => 'Edit '.$node->field_label[0]['value'].' class.')
      );
      $links['neologism_add_subclass'] = array(
        'title' => t('Create new subclass'),
        'href' => "node/add/" . $class_url_str . "/parent/$node->nid",
      	'attributes' => array('title' => 'Create a new class as subclass of '.$node->field_label[0]['value'].'.')	
      );
    }

    if (user_access(PERMISSION_EDIT_VOCABULARIES) && $node->type == NEOLOGISM_CT_PROPERTY) {
      $links['neologism_edit_property'] = array(
        'title' => t('Edit'),
        'href' => "node/$node->nid/edit",
        'query' => $destination,
      );
      $links['neologism_add_subproperty'] = array(
        'title' => t('Create new subproperty'),
        'href' => "node/add/" . $property_url_str . "/parent/$node->nid",
      	'attributes' => array('title' => 'Create a new property as subproperty of '.$node->field_label[0]['value'].'.')	
      );
    }

    return $links;
}


/**
 * Implementation of hook_nodeapi().
 */
function neologism_nodeapi(&$node, $op, $teaser, $page) {
	//var_dump('neologism_nodeapi');
	//var_dump($op, $node->type);
	switch ($op) {
  	case 'prepare':
  		if( $node->type == NEOLOGISM_CT_CLASS ) {
  			variable_set('previous_class_title', $node->title);
      	
  			// TODO working in this commented code, tvm guidocecilio
  			/*
  			if( !isset($node->vocabulary) ) {
      		$vocabulary_nid = NULL;
  				if( arg(2) == 'edit' ) {
      			$vocabulary_nid = $node->field_vocabulary[0]['nid']; // there is different way to get this value
      		}
      		else if( arg(3) == 'parent' ) {
      			$node_class = node_load(arg(4));
      			$vocabulary_nid = $node_class->field_vocabulary[0]['nid'];
      		}
      		else if( isset($_GET['v']) ) {
      			$vocabulary_nid = (int)$_GET['v'];
      		}
      		
      		$vocabulary = node_load($vocabulary_nid);	
      	}
      	kpr($node);
      	*/
      	
      }
      else if( $node->type == NEOLOGISM_CT_PROPERTY ) {
        variable_set('previous_property_title', $node->title);
      }
 
  	  break;
  	  
  	case 'load':
  		if( $node->type == NEOLOGISM_CT_CLASS ) {
				$node->vocabulary = node_load($node->field_vocabulary[0]['nid']);
  		} 
  		else if( $node->type == NEOLOGISM_CT_PROPERTY ) {
				$node->vocabulary = node_load($node->field_vocabulary[0]['nid']);
  		}
  		break;
  		

  	// catching the view event
    case 'view':
    	if( $node->type == NEOLOGISM_CT_VOCABULARY ) {
        $node->authors = array();
        foreach($node->field_authors as $author) {
          $author = user_load($author);
          $name = empty($author->profile_neologism_fullname) ? $author->name : $author->profile_neologism_fullname;
          if ($author->profile_neologism_homepage) {
            $node->authors[] = l($name, $author->profile_neologism_homepage);
          } else {
            $node->authors[] = $name;
          }
        }
        
       	$node->namespace_uri = _neologism_get_namespace_uri($node);
	    	
        // this is a fast solution to show the vocabulary statistic to the user
	    	$node->count_classes = db_result(db_query(db_rewrite_sql("SELECT COUNT(*) FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_CLASS));
	    	$node->count_properties = db_result(db_query(db_rewrite_sql("SELECT COUNT(*) FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_PROPERTY));
      }
      //else if( $node->type == NEOLOGISM_CT_CLASS ) {
      //	drupal_set_breadcrumb(_neologism_build_breadcrumb($node->path));
      //}
      break;
      
    case 'update':
      if($node->type == NEOLOGISM_CT_VOCABULARY) {
        _neologism_update_aliases($node);
      }
      elseif( $node->type == NEOLOGISM_CT_CLASS ) {
        $term = array();
        
        // $node->update_by_reference is used when an update comes from other references than a normal update
        $term['previous_id'] = !isset($node->update_by_reference) ? variable_get('previous_class_title', $node->title) : $node->title;
        $term['id'] = $node->title;
        $term['type'] = 'class';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normalize the superclasses array to used by evoc's evoc_write_class() method
        $term['superclasses'] = array();
        if( !empty($node->field_superclass2) && is_array($node->field_superclass2) ) {
          foreach ( $node->field_superclass2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term['superclasses'][] = $value['evoc_term'];
            }
          }
        }
        
      	$term[EVOC_DISJOINTS] = array();
        if( !empty($node->field_disjointwith2) && is_array($node->field_disjointwith2) ) {
          foreach ( $node->field_disjointwith2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DISJOINTS][] = $value['evoc_term'];
            }
          }
        }
        
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        evoc_update_class($term);  
      }
      elseif( $node->type == NEOLOGISM_CT_PROPERTY ) {
      	$term = array();
        // $node->update_by_reference is used when an update comes from other references than a normal update
        $term['previous_id'] = !isset($node->update_by_reference) ? variable_get('previous_property_title', $node->title) : $node->title;
        $term['id'] = $node->title;
        $term['type'] = 'property';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normaliza the evoc's fields
        $term[EVOC_DOMAINS] = array();
        if( !empty($node->field_domain2) && is_array($node->field_domain2) ) {
          foreach ( $node->field_domain2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DOMAINS][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_RANGES] = array();
        if( !empty($node->field_range2) && is_array($node->field_range2) ) {
          foreach ( $node->field_range2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_RANGES][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_SUPERPROPERTIES] = array();
        if( !empty($node->field_superproperty2) && is_array($node->field_superproperty2) ) {
          foreach ( $node->field_superproperty2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_SUPERPROPERTIES][] = $value['evoc_term'];
            }
          }
        }
        
        //kpr($form);
      	$term[EVOC_INVERSES] = array();
        if( !empty($node->field_inverse2) && is_array($node->field_inverse2) ) {
          foreach ( $node->field_inverse2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_INVERSES][] = $value['evoc_term'];
            }
          }
        }
        
        // inverse normalizatio should goes here
        $term[EVOC_INVERSE] = $node->field_inverse2[0]['evoc_term'];
 
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        evoc_update_property($term);  
      }
      
      break;
    
    case 'insert':
      // Create a user friendly alias to the vocabulary node
      if($node->type == NEOLOGISM_CT_VOCABULARY) {
        _neologism_set_aliases($node);
      }
      
      // Update evoc terms repository
      // we don't need to worry about the existence of this term in the respository
      // evoc module check this for us.
      
      // behavior to update evoc's classes list when a new class' content type is added.
      elseif( $node->type == NEOLOGISM_CT_CLASS ) {
        $term = array();
        $term['id'] = $node->title;
        $term['type'] = 'class';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normalize the superclasses array to used by evoc's evoc_write_class() method
        $term[EVOC_SUPERCLASSES] = array();
        if( !empty($node->field_superclass2) && is_array($node->field_superclass2) ) {
          foreach ( $node->field_superclass2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_SUPERCLASSES][] = $value['evoc_term'];
            }
          }
        }
        
      	$term[EVOC_DISJOINTS] = array();
        if( !empty($node->field_disjointwith2) && is_array($node->field_disjointwith2) ) {
          foreach ( $node->field_disjointwith2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DISJOINTS][] = $value['evoc_term'];
            }
          }
        }
        
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        evoc_write_class($term);  
      }
      
      // behavior to update evoc's properties list when a new property's content type is added 
      elseif( $node->type == NEOLOGISM_CT_PROPERTY ) {
        $term = array();
        $term['id'] = $node->title;
        $term['type'] = 'property';
        $term['label'] = $node->field_label[0]['value']; 
        $term['comment'] = $node->field_comment[0]['value'];
        
        // normaliza the evoc's fields
        $term[EVOC_DOMAINS] = array();
        if( !empty($node->field_domain2) && is_array($node->field_domain2) ) {
          foreach ( $node->field_domain2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_DOMAINS][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_RANGES] = array();
        if( !empty($node->field_range2) && is_array($node->field_range2) ) {
          foreach ( $node->field_range2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_RANGES][] = $value['evoc_term'];
            }
          }
        }
        
        $term[EVOC_SUPERPROPERTIES] = array();
        if( !empty($node->field_superproperty2) && is_array($node->field_superproperty2) ) {
          foreach ( $node->field_superproperty2 as $value ) {
            if( !empty($value['evoc_term']) ) {
              $term[EVOC_SUPERPROPERTIES][] = $value['evoc_term'];
            }
          }
        }
        
      	//kpr($form);
      	$term[EVOC_INVERSE] = $node->field_inverse2[0]['evoc_term'];
 
        // load vocabulary's node to get its title as namespace/prefix for this class 
        $vocabulary = node_load($node->field_vocabulary[0][nid]);
        $term['prefix'] = $vocabulary->title; 
        
        evoc_write_property($term);  
      }

      break;
    
   
    
    case 'delete':
      // Deletion of the aliases when deleting a vocabulary
      if($node->type == NEOLOGISM_CT_VOCABULARY) {
        _neologism_unset_aliases($node);
        _neologism_on_deleted_vocabulary_node($node);
      } 
      else if($node->type == NEOLOGISM_CT_CLASS) {
        _neologism_on_deleted_class_node($node);
      }
      else if($node->type == NEOLOGISM_CT_PROPERTY) {
        _neologism_on_deleted_property_node($node);
      }
      
      break;
  
    default:
  }

}

/**
 * Get the best content type requested
 */
function neologism_get_preferred_content($accept) {
  if (isset($accept)) {
    include_once(CONTENT_NEGOTATION_DIR."content_negotiation.inc.php");
    // Stupid browsers that send */* should get HTML, so give
    // highest preference ot that. We prefer XHTML over HTML if
    // both are supported. Among RDF formats, RDF/XML has precedence
    // over Turtle and N3. We also map application/xml to
    // RDF/XML.
    $supported_types = array(
      'type' => array(
        'application/xhtml+xml',
        'text/html',
        'application/rdf+xml',
        'text/rdf+n3',
        'text/turtle',
        'application/xml',
      ),
      'app_preference' => array(
        1.00,
        0.99,
        0.90,
        0.88,
        0.89,
        0.50,
      ),
    );
    
    $best = content_negotiation::mime_best_negotiation($supported_types);
    if ($best == "application/rdf+xml")
      return RDF;
    else if ($best == "text/rdf+n3" || $best == "text/turtle")
      return N3;
    else if ($best == "application/xml")
      return RDF;
    else
      return HTML;
   } else {
     return RDF;
   }
}


/**
 * Get the best uri requested
 */
function neologism_get_preferred_uri($uri, $accept) {
    $uri = "http://" . $_SERVER["HTTP_HOST"] . $uri;
    $preferred = neologism_get_preferred_content($accept);
    if (substr($uri, -1)=="/")
        return $uri . $preferred;
    else
        return $uri . "." . $preferred;
}



/**
* Implementation of hook_rdf_namespaces().
* load all the vocabularies as namespaces
*/
function neologism_rdf_namespaces() {

  // Start with the namespaces required in Neologism's RDF output
  $namespaces = array(
// The rdf module behaves funny if the same prefix is assigned twice,
// even if to the same URI. So we just hope that they are declared.
//    'rdf' => 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
//    'rdfs' => 'http://www.w3.org/2000/01/rdf-schema#',
//    'dc' => 'http://purl.org/dc/elements/1.1/',
//    'owl' => 'http://www.w3.org/2002/07/owl#',
//    'foaf' => 'http://xmlns.com/foaf/0.1/',
    'vann' => 'http://purl.org/vocab/vann/',
  );

  // Add namespaces of all user-created vocabularies
  // TODO Use the node's path instead of title when no custom namespace is defined
  $vocs = db_query(db_rewrite_sql("SELECT n.title, c.field_custom_namespace_value AS custom FROM {content_type_neo_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE n.type = '%s'"), NEOLOGISM_CT_VOCABULARY);
  while( $voc = db_fetch_object($vocs) ) {
    $namespaces[$voc->title] = $voc->custom ? $voc->custom : url($voc->title, array('absolute' => TRUE)) . '#';
  }

  return $namespaces;
}



/**
 * hook_removed_external_vocabulary($prefix)
 * this hook is called by evoc module after a namespace is removed from its repository
 * @param object $prefix removed
 * @return 
 */
function neologism_removed_external_vocabulary($prefix) {
  $classes = db_query(db_rewrite_sql("select nid from {node} where type = '%s'"), NEOLOGISM_CT_CLASS);
  while ( $class = db_fetch_object($classes) ) {
    $nclass = (object) node_load($class->nid);
    $need_update = FALSE;
    
    if( isset($nclass->field_superclass2[0]['evoc_term']) ) {
      foreach ( $nclass->field_superclass2 as &$value ) {
        $qname_splitted = explode(':', $value['evoc_term']); 
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( isset($nclass->field_disjointwith2[0]['evoc_term']) ) {
      foreach ( $nclass->field_disjointwith2 as &$value ) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if ( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nclass);
    }
    
  }
  
  // check for properties
  $properties = db_query(db_rewrite_sql("select nid from {node} where type = '%s'"), NEOLOGISM_CT_PROPERTY); 
  while( $property = db_fetch_object($properties) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nproperty = (object) node_load($property->nid);
    $need_update = FALSE;
    
    if( isset($nproperty->field_domain2[0]['evoc_term']) ) {
      foreach($nproperty->field_domain2 as &$value) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( isset($nproperty->field_range2[0]['evoc_term']) ) {
      foreach($nproperty->field_range2 as &$value) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( isset($nproperty->field_superproperty2[0]['evoc_term']) ) {
      foreach($nproperty->field_superproperty2 as &$value) {
        $qname_splitted = explode(':', $value['evoc_term']);
        if( $qname_splitted[0] == $prefix ) {
          $value['evoc_term'] = NULL;
          $need_update = TRUE;
        }
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nproperty);
    }
  } // check for properties
}

//-------------------------------------------------------------------------------------------------------
// theming section

/*
 * Clone of the core theme_item_list but without the <div> which messes up the treeview plugin.
 */
function theme_neologism_item_list($items = array(), $title = NULL, $type = 'ul', $attributes = NULL) {
  $output = '';

  if (!empty($items)) {
    $output .= "<$type". drupal_attributes($attributes) .'>';
    // We empty $attributes here as we want a clean nested list without the ids.
    $attributes = NULL;
    $num_items = count($items);
    foreach ($items as $i => $item) {
      $attributes = array();
      $children = array();
      if (is_array($item)) {
        foreach ($item as $key => $value) {
          if ($key == 'data') {
            $data = $value;
          }
          elseif ($key == 'children') {
            $children = $value;
          }
          else {
            $attributes[$key] = $value;
          }
        }
      }
      else {
        $data = $item;
      }
      if (count($children) > 0) {
        $data .= theme_neologism_item_list($children, NULL, $type, $attributes); // Render nested list
      }
      if ($i == 0) {
        $attributes['class'] = empty($attributes['class']) ? 'first' : ($attributes['class'] .' first');
      }
      if ($i == $num_items - 1) {
        $attributes['class'] = empty($attributes['class']) ? 'last' : ($attributes['class'] .' last');
      }
      // drupal_attributes($attributes) has been removed here to prevent useless attributes.
      $output .= '<li>'. $data ."</li>\n";
    }
    $output .= "</$type>";
  }
  return $output;
}

function theme_class_view($node, $teaser = FALSE, $page = FALSE, $links = TRUE) {
	$node = (object)$node;
  $output = '';
  
  $node = node_build_content($node, $teaser, $page);
  
  $URI ='';
  if ( !empty($node->vocabulary->field_custom_namespace[0]['value']) ) {
  	$curi = _neologism_get_namespace_uri($node->vocabulary) . $node->title;
  	$link = l($curi, $curi);
  	$URI = '<div class="row"><div class="column-title">URI:</div><div class="column-values">'.$link.'</div></div>';
  }
  
  
  $superclasses = '';
  if ( !empty($node->content['field_superclass2']['field']['items'][0]['#item']['evoc_term']) ) {
    $superclasses .= '<div class="row"><div class="column-title">subclass-of:</div><div class="column-values">';
    foreach ( $node->content['field_superclass2']['field']['items'] as $value ) {
      $superclasses .= theme('evocreference_formatter_default', $value).'&nbsp; ';
    }
    $superclasses .= '</div></div>';
  }
  
  $disjointwith = '';
  if ( !empty($node->content['field_disjointwith2']['field']['items'][0]['#item']['evoc_term']) ) {
    $disjointwith .= '<div class="row"><div class="column-title">disjoint-with:</div><div class="column-values">';
    foreach ( $node->content['field_disjointwith2']['field']['items'] as $value ) {
      $disjointwith .= theme('evocreference_formatter_default', $value).'&nbsp ';
    }
    $disjointwith .= '</div></div>';
  }
  
  $comment = '';
  if ( !empty($node->field_comment) ) {
    $comment .= $node->field_comment[0]['value'];
  }
  
  $label = '';
  if ( !empty($node->field_label) ) {
    $label .= $node->field_label[0]['value'];
  }
  
  $teaser_class = ($teaser == TRUE) ? ' class="teaser"' : '';
  $output .= '
  <div id="classview"'.$teaser_class.'">
    <h3 id="'.$node->title.'">Class: '.$node->vocabulary->title.':'.$node->title.'</h3>';
  
  if(empty($comment) ) {    
    $output .= '<div class="abstract"><em>'.$label.'</em></div>';
  } else {
    $output .= '<div class="abstract"><em>'.$label.'</em> - '.$comment.'</div>';
  }
  
  $output .= '
      <div class="properties-block">
      		'.$URI.'    
      		'.$superclasses.'
          '.$disjointwith.'
      </div>
     <div class="description">'.$node->body.'</div>';
     
  if ( $teaser ) {
    $output .= '<div class="linkontop">[<a href="#sec_glance">back to top</a>]</div>';  
  }
	
  if ( $taxonomy ) {
    $output .= '<div class="terms">'.$terms.'</div>';
  }
 
  if ( $links ) {
    $node->links = module_invoke_all('link', 'node', $node, $teaser);
    drupal_alter('link', $node->links, $node);
    $output .= '<div class="links">'.theme('links', $node->links).'</div>';
  }
  
  $output .= '</div>';
 
  return $output; 
}

function theme_property_view($node, $teaser = FALSE, $page = FALSE, $links = TRUE) {
	$node = (object)$node;
  $output = '';
  
  // build context to use the evoc fields values
  $node = node_build_content($node, $teaser, $page);
  
  $URI ='';
  if ( !empty($node->vocabulary->field_custom_namespace[0]['value']) ) {
  	$curi = _neologism_get_namespace_uri($node->vocabulary) . $node->title;
  	$link = l($curi, $curi);
  	$URI = '<div class="row"><div class="column-title">URI:</div><div class="column-values">'.$link.'</div></div>';
  }
  
  $owl_type = '';
  $owl_type_value = '';
  $isfp = !empty($node->field_fp[0]['value']);
  $isifp = !empty($node->field_ifp[0]['value']);  
  if( $isfp ) {
    $owl_type = '<div class="row"><div class="column-title">OWL Type:</div><div class="column-values">';
    $owl_type .= '<a href="http://www.w3.org/2002/07/owl#FunctionalProperty">owl:FunctionalProperty</a>';  
  }
  if( $isifp ) {
    if( !$isfp ) {
      $owl_type = '<div class="row"><div class="column-title">OWL Type:</div><div class="column-values">';
    }
    else {
      $owl_type .= ', ';
    }
    $owl_type .= '<a href="http://www.w3.org/2002/07/owl#InverseFunctionalProperty">owl:InverseFunctionalProperty</a>';
  }
  if( $isfp || $isifp ) {
    $owl_type .= '</div></div>';
  }
    
  $domain = '';
  if ( !empty($node->content['field_domain2']['field']['items'][0]['#item']['evoc_term']) ) {
    $domain .= '<div class="row"><div class="column-title">Domain:</div><div class="column-values">';
    foreach ( $node->content['field_domain2']['field']['items'] as $value ) {
      $domain .= theme('evocreference_formatter_default', $value).'&nbsp ';
    }
    $domain .= '</div></div>';
  }
  
  $range = '';
  if ( !empty($node->content['field_range2']['field']['items'][0]['#item']['evoc_term']) ) {
    $range .= '<div class="row"><div class="column-title">Range:</div><div class="column-values">';
    foreach ( $node->content['field_range2']['field']['items'] as $value ) {
      $range .= theme('evocreference_formatter_default', $value).'&nbsp ';
    }
    $range .= '</div></div>';
  }
  
  $inverse = '';
  if ( !empty($node->content['field_inverse2']['field']['items'][0]['#item']['evoc_term']) ) {
    $inverse .= '<div class="row"><div class="column-title">Inverse-of:</div><div class="column-values">';
    foreach ( $node->content['field_inverse2']['field']['items'] as $value ) {
      $inverse .= theme('evocreference_formatter_default', $value).'&nbsp ';
    }
    $inverse .= '</div></div>';
  }
  
  $subproperty_of = '';
  if ( !empty($node->content['field_superproperty2']['field']['items'][0]['#item']['evoc_term']) ) {
    $subproperty_of .= '<div class="row"><div class="column-title">subproperty-of:</div><div class="column-values">';
    foreach ( $node->content['field_superproperty2']['field']['items'] as $value ) {
      $subproperty_of .= theme('evocreference_formatter_default', $value).'&nbsp ';
    }
    $subproperty_of .= '</div></div>';
  }
  
  $comment = '';
  if ( !empty($node->field_comment) ) {
    $comment .= $node->field_comment[0]['value'];
  }
  
	$label = '';
  if ( !empty($node->field_label) ) {
    $label .= $node->field_label[0]['value'];
  }
  
  $description = '';
	if ( !empty($node->body_field) ) {
    $description = $node->body_field;
  }
  
  $teaser_property = ($teaser == TRUE) ? ' class="teaser"' : '';
  $output .= '
  <div id="propertyview" '.$teaser_property.'>
    <h3 id="'.$node->title.'">Property: '.$node->vocabulary->title.':'.$node->title.'</h3>';
	
  if(empty($comment) ) {    
    $output .= '<div class="abstract"><em>'.$label.'</em></div>';
  } else {
    $output .= '<div class="abstract"><em>'.$label.'</em> - '.$comment.'</div>';
  }
  
  $output .= '
      <div class="properties-block">
		      '.$URI.'     
		      '.$owl_type.'
          '.$inverse.'
          '.$subproperty_of.'
          '.$domain.'
          '.$range.'
      </div>
     <div class="description">'.$description.'</div>';
     
  if ( $teaser ) {
    $output .= '<div class="linkontop">[<a href="#sec_glance">back to top</a>]</div>';  
  }
	
  if ( $taxonomy ) {
    $output .= '<div class="terms">'.$terms.'</div>';
  }
 
  if ( $links ) {
    $node->links = module_invoke_all('link', 'node', $node, $teaser);
    drupal_alter('link', $node->links, $node);
    $output .= '<div class="links">'.theme('links', $node->links).'</div>';
  }
  
  $output .= '</div>';
 
  return $output; 
}

/**
 * 
 * @param $form
 * @return unknown_type
 */
function theme_neo_vocabulary_node_form($form) {
	$output = '';
	
	$buttons = drupal_render($form['buttons']);
	$URI = drupal_render($form['title']);
	$title = drupal_render($form['field_title']);
	$custom_namespace = drupal_render($form['field_custom_namespace']);
	
	$node = $form['#node'];
	drupal_set_breadcrumb(_neologism_build_breadcrumb($node->path));
	drupal_set_title($node->field_title[0]['value']);
	
	$output .= $URI.$title.$custom_namespace.drupal_render($form).$buttons;
	return $output;
}

/**
 * 
 * @param $form
 * @return unknown_type
 */
function theme_neo_property_node_form($form) {
	$buttons = drupal_render($form['buttons']);
	$URI = drupal_render($form['title']);
	$label = drupal_render($form['field_label']);
	$comment = drupal_render($form['field_comment']);
	$domain = drupal_render($form['field_domain2']);
	//$grouprange = drupal_render($form['group_range']);
	//$description = drupal_render($form['field_description2']);
	$description = drupal_render($form['body_field']);
	$inverse = drupal_render($form['field_inverse2']);
	$fp = drupal_render($form['field_fp']);
	$ifp = drupal_render($form['field_ifp']);
	$superproperty = drupal_render($form['field_superproperty2']);
  
  $range_group = drupal_render($form['range_group']['resource_type']);
  $range_group .= drupal_render($form['field_range2']);
  $range_group .=drupal_render($form['range_group']['data_types']);
  
  $formtitle = 'Create new property';
  if( isset($form['holder']) ) {
  	$path = $form['holder']['#value']['vocabulary_title'];
  	if( $form['holder']['#value']['operation'] == 'edit' ) {
  		$formtitle = 'Editing '.$form['holder']['#value']['qname'];
  	}
  }
  
	drupal_set_breadcrumb(_neologism_build_breadcrumb($path));
	drupal_set_title($formtitle);
  
	$output = $URI.$label.$comment.$description.$fp.$ifp.$domain.$range_group.$superproperty.$inverse.drupal_render($form).$buttons;
	//$output = drupal_render($form).$buttons;
	return $output;
}

/**
 * 
 * @param $form
 * @return unknown_type
 */
function theme_neo_class_node_form($form) {
	$output = '';
	$buttons = drupal_render($form['buttons']);
	$URI = drupal_render($form['title']);
	$label = drupal_render($form['field_label']);
	$comment = drupal_render($form['field_comment']);
	$description = drupal_render($form['body_field']);
	
	$formtitle = 'Create new class';
  if( isset($form['holder']) ) {
  	$path = $form['holder']['#value']['vocabulary_title'];
  	if( $form['holder']['#value']['operation'] == 'edit' ) {
  		$formtitle = 'Editing '.$form['holder']['#value']['qname'];
  	}
  }
	drupal_set_breadcrumb(_neologism_build_breadcrumb($path));
	drupal_set_title($formtitle);
	
	$output .= $URI.$label.$comment.$description.drupal_render($form).$buttons;
	return $output;
}

function theme_render_URI_field($element) {
  $size = empty($element['#size']) ? '' : ' size="'. $element['#size'] .'"';
  $maxlength = empty($element['#maxlength']) ? '' : ' maxlength="'. $element['#maxlength'] .'"';
  $class = array('form-text');
  $extra = '';
  $output = '';

  if ($element['#autocomplete_path'] && menu_valid_path(array('link_path' => $element['#autocomplete_path']))) {
    drupal_add_js('misc/autocomplete.js');
    $class[] = 'form-autocomplete';
    $extra =  '<input class="autocomplete" type="hidden" id="'. $element['#id'] .'-autocomplete" value="'. check_url(url($element['#autocomplete_path'], array('absolute' => TRUE))) .'" disabled="disabled" />';
  }
  
  _form_set_class($element, $class);

  if (isset($element['#field_prefix'])) {
    $output .= '<span class="field-prefix">'. $element['#field_prefix'] .'</span> ';
  }

  $output .= '<input type="text"'. $maxlength .' name="'. $element['#name'] .'" id="'. $element['#id'] .'"'. $size .' value="'. check_plain($element['#value']) .'"'. drupal_attributes($element['#attributes']) .' />';

  if (isset($element['#field_suffix'])) {
    $output .= ' <span class="field-suffix">'. $element['#field_suffix'] .'</span>';
  }

  return theme('neologism_form_element', $element, $output) . $extra;
}

function theme_render_custom_namespace_field($element) {
	// TODO: add the classes to the field_custom_namespace when some error it is sent to the form

	$default_value = isset($element[0]['#default_value']['value']) ? $element[0]['#default_value']['value'] : '';
    $default_namespace = $element['#default_namespace'];
	$default_namespace = substr($default_namespace, 0, strrpos($default_namespace, '/') + 1);
    $default_namespace = $default_namespace . '<i>vocabulary_ID</i>#';

	$output = ' 
	  <div id="range-group-resourcetype">
	  <div class="form-item">
	 		<label>Namespace URI: </label>
	 		<div class="form-radios"><div class="form-item" id="edit-namespace-type-1-wrapper">
	 			<label class="option" for="edit-namespace-type-1">
	 				<input type="radio" id="edit-namespace-type-1" name="namespace_type" value="1"  checked="checked"  onClick="Neologism.neoVocabularyFormToggleNamespace()" class="form-radio" /> Default ('.$default_namespace.')
	 			</label>
				</div>
					<div class="form-item" id="edit-namespace-type-2-wrapper">
		 				<label class="option" for="edit-namespace-type-2"><input type="radio" id="edit-namespace-type-2" name="namespace_type" value="2"   onClick="Neologism.neoVocabularyFormToggleNamespace()" class="form-radio" /> Custom</label>
					  <input type="text" disabled="disabled" name="field_custom_namespace[0][value]" id="edit-field-custom-namespace-0-value" size="60" value="'.$default_value.'" class="form-text text" />
		 			</div>
			</div>
	</div>
	</div>
	';
  return $output;
}

/**
 * This function is an exactly copy of theme_form_element but adpted for neologism
 * @param $element
 * @param $value
 * @return unknown_type
 */
function theme_neologism_form_element(array $element, $value) {
	//dpm($element);
	$t = get_t();
	
	$output = '<div class="form-item"';
  if (!empty($element['#id'])) {
    $output .= ' id="'. $element['#id'] .'-wrapper"';
  }
  $output .= ">\n";
  $required = !empty($element['#required']) ? '<span class="form-required" title="'. $t('This field is required.') .'">*</span>' : '';

  if (!empty($element['#title'])) {
    $title = $element['#title'];
    if (!empty($element['#id'])) {
      $output .= ' <label for="'. $element['#id'] .'">'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";
    }
    else {
      $output .= ' <label>'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";
    }
  }

  $output .= " <span>".$element['#namespace']."</span> $value\n";

  if (!empty($element['#description'])) {
    $output .= ' <div class="description">'. $element['#description'] ."</div>\n";
  }

  $output .= "</div>\n";

  return $output;
}

// end theming section
//-------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------
// private functions

/**
 * update the url_alias table the alias 
 * @param object $node
 * @return 
 */
function _neologism_update_aliases($node) {
  _neologism_unset_aliases($node);
  _neologism_set_aliases($node);
}

/**
 * Create a alias in the url_alias table for the $node 
 * @param object $node
 * @return 
 */
function _neologism_set_aliases($node) {
  $path = check_plain($node->title);
  path_set_alias("node/$node->nid", $path, NULL, $node->language );
  path_set_alias("node/$node->nid/".HTML, $path.'.'.HTML, NULL, $node->language);
  path_set_alias("node/$node->nid/".RDF, $path.'.'.RDF, NULL, $node->language);
  path_set_alias("node/$node->nid/".N3, $path.'.'.N3, NULL, $node->language);
  path_set_alias("node/$node->nid/".XML, $path.'.'.XML, NULL, $node->language);
  path_set_alias("node/$node->nid/".LAYOUT, $path.'.'.LAYOUT, NULL, $node->language);
}

/**
 * Remove from the url_alias table the alias create for each vocabulary's node
 * @param object $node
 * @return 
 */
function _neologism_unset_aliases($node) {
  path_set_alias(NULL, $node->path, NULL, $node->language);
  path_set_alias(NULL, $node->path.'.'.HTML, NULL, $node->language);
  path_set_alias(NULL, $node->path.'.'.RDF, NULL, $node->language);
  path_set_alias(NULL, $node->path.'.'.N3, NULL, $node->language);
  path_set_alias(NULL, $node->path.'.'.XML, NULL, $node->language);
  path_set_alias(NULL, $node->path.'.'.LAYOUT, NULL, $node->language);
}

/**
 * Get all properties in a vocabulary
 */
function _neologism_get_all_properties($node, array &$detect_namespaces = NULL) {
  $properties_resource = db_query(db_rewrite_sql("select n.nid from {content_field_vocabulary} c inner join {node} n on c.nid = n.nid where c.field_vocabulary_nid = %d and n.type = '%s'"), $node->nid, NEOLOGISM_CT_PROPERTY);
  $i = 0;
  
  $properties = array(); 
  while ( $item = db_fetch_object($properties_resource) ) {
    $fullnode = node_load($item->nid);
    
    $properties[$i]['nid'] = $item->nid;
    $properties[$i]['id'] = $fullnode->title;
    $properties[$i]['label'] = $fullnode->field_label[0]['value'];
    if( !empty($fullnode->field_comment[0]['value']) ) {
      $properties[$i]['comment'] = $fullnode->field_comment[0]['value'];
    }
    
    if ( isset($fullnode->field_domain2[0]['evoc_term']) && $fullnode->field_domain2[0]['evoc_term'] ) {
      $properties[$i][DOMAINS] = array();
      foreach ( $fullnode->field_domain2 as $term => $value ) {
        $properties[$i][DOMAINS][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if ( isset($fullnode->field_range2[0]['evoc_term']) && $fullnode->field_range2[0]['evoc_term'] ) {
      $properties[$i][RANGES] = array();
      foreach ( $fullnode->field_range2 as $term => $value ) {
        $properties[$i][RANGES][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if ( isset($fullnode->field_superproperty2[0]['evoc_term']) && $fullnode->field_superproperty2[0]['evoc_term'] ) {
      $properties[$i][SUBPROPERTYOF] = array();
      foreach ( $fullnode->field_superproperty2 as $term => $value ) {
        $properties[$i][SUBPROPERTYOF][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if( isset($fullnode->field_ifp[0]['value']) && $fullnode->field_ifp[0]['value'] == '1' ) {
      $properties[$i]['isInverseFunctional'] = TRUE;
    }
    
    if( isset($fullnode->field_fp[0]['value']) && $fullnode->field_fp[0]['value'] == '1' ) {
      $properties[$i]['isFunctional'] = TRUE;
    }
    
    if( !empty($fullnode->body) ) {
      $properties[$i]['description'] = $fullnode->body;
    }
      
    $i++;
  }
  
  return $properties;
}

/**
 * Get all classes in a vocabulary
 */
function _neologism_get_all_classes($node, array &$detect_namespaces = NULL) {
  
  $classes_resource = db_query(db_rewrite_sql("SELECT n.nid FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_CLASS);
  $i = 0;
  
  $classes = array(); 
  while ( $item = db_fetch_object($classes_resource) ) {
    $fullnode = node_load($item->nid);
    
    $classes[$i]['nid'] = $item->nid;
    $classes[$i]['id'] = $fullnode->title;
    $classes[$i]['label'] = $fullnode->field_label[0]['value'];
    if( !empty($fullnode->field_comment[0]['value']) ) {
      $classes[$i]['comment'] = $fullnode->field_comment[0]['value'];
    }
    
    if ( isset($fullnode->field_superclass2[0]['evoc_term']) && $fullnode->field_superclass2[0]['evoc_term'] ) {
      $classes[$i][SUPERCLASSES] = array();
      foreach ( $fullnode->field_superclass2 as $term => $value ) {
        $classes[$i][SUPERCLASSES][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if ( isset($fullnode->field_disjointwith2[0]['evoc_term']) && $fullnode->field_disjointwith2[0]['evoc_term'] ) {
      $classes[$i][DISJOINTS_WITH] = array();
      foreach ( $fullnode->field_disjointwith2 as $term => $value ) {
        $classes[$i][DISJOINTS_WITH][] = $value['evoc_term'];
        
        if ( isset($detect_namespaces) ) {
          $qname_splitted = explode(':', $value['evoc_term']);
          if( !in_array($qname_splitted[0], $detect_namespaces) ) {
            $detect_namespaces[] = $qname_splitted[0];
          }  
        }
      }  
    }
    
    if( !empty($fullnode->body) ) {
      $classes[$i]['description'] = $fullnode->body;
    }
      
    $i++;
  }
  
  return $classes;
}

//-------------------------------------------------------------------------------------------------------
// validations hooks for the content types classes and properties
// These methods to validate both form, classes and properties are provisional
// 
/**
 * 
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
function neo_vocabulary_node_form_validate($form, &$form_state) {
  $title = $form_state['values']['title'];
  if ( !_neologism_is_valid_id($title) ) {
    form_set_error('title', t('"'.$title.'" - '.MSG_INVALID_ID));
  }
  
	$custom_namespace = $form_state['values']['field_custom_namespace'][0]['value'];
  // the cosntant error_field_required_empty is handled in Neologism.js file
  if( $custom_namespace != '' ) {
    if( $custom_namespace == 'error_field_required_empty' ) {
      form_set_error('field_custom_namespace', t('This field is required in your selection.'));  
      return;
    }
    if(!rdf_is_valid_uri($custom_namespace) ) {
      form_set_error('field_custom_namespace', t('Invalid namespace URI. A valid example is <i>http://xmlns.com/foaf/0.1/</i>'));  
      return;
    }
    if (substr($custom_namespace, -1) != '#' && substr($custom_namespace, -1) != '/') {
      form_set_error('field_custom_namespace', t('The custom namespace URI must end in “#” or “/”.'));
      return;
    }
  }
  
  $count = db_result( db_query( db_rewrite_sql('SELECT count(*) FROM {node} WHERE title="%s" AND type = "%s"'), $title, NEOLOGISM_CT_VOCABULARY ));
  if( $count > 0 ) {
  	form_set_error('title', t('"'.$title.'" - '.MSG_ID_ALREADY_EXISTS));	
  }
  
	// check the route table
  $array_of_path = array();
  $result = db_query( db_rewrite_sql('SELECT path FROM menu_router'));
  while( $row = db_fetch_object($result)) {
  	if( strpos($row->path, '/') === FALSE ) {
  		if( $row->path === $title ) {
	  		form_set_error('title', t('"'.$title.'" - '.MSG_ID_ALREADY_IN_USE_FOR_DRUPAL));
	  		return;	
	  	}
  	}
  }
}

/**
 * on submit handler for vocabulary 
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
/*
function neo_vocabulary_node_form_submit($form, &$form_state) {
}
*/

/**
 * Handler for validation form for the neo_class node form
 *  
 * @param object $form
 * @param object $form_state
 * @return 
 */
function neo_class_node_form_validate($form, &$form_state) {
//function _neologism_neo_class_node_form_validate($form, &$form_state) {
  // due the node module check for the existences of the title we just to check it 
  // when the user select a name this name doesn't exists in the same vocabulary.
  // check if the action is over a new node
  //if( !$form_state['values']['nid'] ) {
    $vocabulary_nid = $form_state['values']['field_vocabulary'][0]['nid'];
    $class_title = $form_state['values']['title'];
    if ( !_neologism_is_valid_id($class_title) ) {
      form_set_error('title', t('"'.$class_title.'" - '.MSG_INVALID_ID));
    }
    
    if( $form_state['values']['field_label'][0]['value'] == '' ) {
      form_set_error('field_label', t('You must specify a label for this class.'));
    }
  
    if( empty($form_state['values']['field_superclass2']) ) {
      form_set_error('field_superclass2', t('You must select a superclass for this class.'));
    }
    else {
      // TODO do a global select and then compare with the selected value. 
      // This way consume too much resources whether there exist many classes.
      foreach( $form_state['values']['field_superclass2'] as $value ) {
        // FIXME there is some error with external superclasses that doesn't has superclasses
        if( !evoc_term_exists(NULL, $value['evoc_term'], TRUE) ) {
            form_set_error('field_superclass2', t('You must select a super class from one of the class that match your criterial. If that class does not exists in the system, please import it.'));
        }
      }
    }
    
  //} // end if
}

/**
 * Handler for validation form for the neo_property node form
 * 
 * @param object $form
 * @param object $form_state
 * @return 
 */
function neo_property_node_form_validate($form, &$form_state) {
  // check for a new property
	//if( !$form_state['values']['nid'] ) {
    $vocabulary_nid = $form_state['values']['field_vocabulary'][0]['nid'];
    $property_title = $form_state['values']['title'];
    
    // check that current property doesn't exists in the same vocabulary
    if ( !_neologism_is_valid_id($property_title) ) {
      form_set_error('title', t('"'.$class_title.'" - '.MSG_INVALID_ID));
    }
    
    // check for the property's domain. if the class selected already exists in the system
    foreach( $form_state['values']['field_domain2'] as $value ) {
      if( !evoc_term_exists(NULL, $value['evoc_term'], TRUE) ) {
        form_set_error('field_domain2', t('You must select a domain from one of the class that match your criterial. If that class does not exists in the system, please import it.'));
      }
    }
    
    // if $form_state['values']['resource_type'] == '1' everithing come fine
    if( $form_state['values']['resource_type'] == '2' ) {
    	$form_state['values']['field_range2'][0]['evoc_term'] = $form_state['values']['data_types'];
    	$form_state['values']['field_inverse2'] = array();
    }
  	else if( $form_state['values']['resource_type'] == '3' ) {
    	$form_state['values']['field_range2'][0] = NULL;
    }
    
    /*
    if( $form_state['values']['field_literal_as_range'][0]['value'] ) {
      $range = "rdfs:Literal";
      // this would be used when save the property to the repository
      $form_state['values']['field_range2'][0]['evoc_term'] = $range;
    }
    */
    
    /*
     * We don't need to check something that is filtered for the system. So we need to remove this 
     * commented piece of code afeter be sure of that
     * 
    // check for the property's ranges. if the range already exists in the system
    if( !empty($form_state['values']['field_range2']) ) {
	    foreach( $form_state['values']['field_range2'] as $value ) {
	      if( !evoc_term_exists(NULL, $value['evoc_term'], TRUE) ) {
	        form_set_error('field_range2', t('You must select a range from one of the terms that match your criterial. If that class does not exists in the system, please import it.'));
	      }
	    }
    }
    */
    
    // check for the property's superproperty field. 
    foreach( $form_state['values']['field_superproperty2'] as $value ) {
      if( !evoc_term_exists(NULL, $value['evoc_term'], FALSE) ) {
        form_set_error('field_superproperty2', t('There is some error selecting your superproperty, the term does not exists in the system.'));
      }
    }
  //}
}

/**
 * 
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
function _neo_class_node_form_submit($form, &$form_state) {
  $form_state['redirect'] = 'node/'.$form_state['values']['field_vocabulary'][0]['nid'];
}

/**
 * 
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
function _neo_property_node_form_submit($form, &$form_state) {
  $form_state['redirect'] = 'node/'.$form_state['values']['field_vocabulary'][0]['nid'];
}

// end validation node section
//-------------------------------------------------------------------------------------------------------

/**
 * Callback launched after a vocabulary node has been deleted. Used in neologism_nodeapi() hook
 * @return none
 * 
 * Handling CCK nodereference orphaned nodes when the parent is deleted?
 * http://drupal.org/node/364539
 * 
 * Inconsistent site left after deleting a parent referenced in a nodereference field
 * http://drupal.org/node/362649 
 */
function _neologism_on_deleted_vocabulary_node($node) {
  //$field_name = 'field_vocabulary';
  //$field = content_fields($field_name); // $field_name is the name of the nodereference field.
  //$db_info = content_database_info($field);
  //$query = 'SELECT nid FROM {'. $db_info['table'] . '} WHERE '. $field_name .'_nid = %d';
  //$result = db_query($query, $node->nid);
  //while ($obj = db_fetch_object($result)) 
  //  var_dump($obj);
  
  // remove all classes belonging to this vocabulary
  $classes = db_query(db_rewrite_sql("SELECT n.nid, n.title FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_CLASS);
  while ($class = db_fetch_object($classes)) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    
    // we need to delete the node without usign node_delete because there is no way to check the vocabulary
    // it belong
    //node_delete($class->nid);
    
    // same code that node_delete but without execute any callback
    $cnode = node_load($class->nid);

    if (node_access('delete', $cnode)) {
      db_query('DELETE FROM {node} WHERE nid = %d', $cnode->nid);
      db_query('DELETE FROM {node_revisions} WHERE nid = %d', $cnode->nid);
  
      // Clear the page and block caches.
      cache_clear_all();
  
      // Remove this node from the search index if needed.
      if (function_exists('search_wipe')) {
        search_wipe($cnode->nid, 'node');
      }
      watchdog('content', '@type: deleted %title.', array('@type' => $cnode->type, '%title' => $cnode->title));
      drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $cnode), '%title' => $cnode->title)));
    }
    
    // check for classes dependence
    _neologism_on_deleted_class_node($cnode, $node->title);
  }
  
  // remove all properties belonging to this vocabulary 
  $properties = db_query(db_rewrite_sql("SELECT n.nid, n.title FROM {content_field_vocabulary} c INNER JOIN {node} n ON c.nid = n.nid WHERE c.field_vocabulary_nid = %d AND n.type = '%s'"), $node->nid, NEOLOGISM_CT_PROPERTY);
  while ($property = db_fetch_object($properties)) {
    // same code that node_delete but without execute any callback
    $pnode = node_load($property->nid);

    if (node_access('delete', $pnode)) {
      db_query('DELETE FROM {node} WHERE nid = %d', $pnode->nid);
      db_query('DELETE FROM {node_revisions} WHERE nid = %d', $pnode->nid);
  
      // Clear the page and block caches.
      cache_clear_all();
  
      // Remove this node from the search index if needed.
      if (function_exists('search_wipe')) {
        search_wipe($pnode->nid, 'node');
      }
      watchdog('content', '@type: deleted %title.', array('@type' => $pnode->type, '%title' => $pnode->title));
      drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $pnode), '%title' => $pnode->title)));
    }
    
    // check for properies dependence
    _neologism_on_deleted_property_node($pnode, $node->title);
  }
}

/**
 * 
 * @param object $node
 * @param object $vocabulary_title [optional]
 * @return 
 */
function _neologism_on_deleted_class_node($node, $vocabulary_title = NULL) {
  // at this point the current class has been removed. 
  // now we have to check for other classes or properties that might be subClasses or disjoints 
  // or properties that might has been using it as domain or range.
  
  if( !$vocabulary_title ) {
    $vocabulary_title = db_fetch_object( db_query( db_rewrite_sql("SELECT n.title FROM {node} n WHERE n.nid = %d"), $node->field_vocabulary[0]['nid']) );
    $vocabulary_title = $vocabulary_title->title;  
  }
  
  // check for classes
  $classes = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = '%s'"), NEOLOGISM_CT_CLASS); 
  while( $class = db_fetch_object($classes) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nclass = (object) node_load($class->nid);
    $need_update = FALSE;
    
    foreach($nclass->field_superclass2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        // if this is the only one superclass assign it the default superclass
        if( count($nclass->field_superclass2) > 0 ) {
          $value['evoc_term'] = $node->field_superclass2[0]['evoc_term'];//DEFAULT_RDFS_SUPERCLASS;
        }
        else {
          $value['evoc_term'] = NULL;
        }
        $need_update = TRUE;
      }
    }
    
    foreach($nclass->field_disjointwith2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nclass);
    }
    
  }
  
  // check for properties
  $properties = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = '%s'"), NEOLOGISM_CT_PROPERTY); 
  while( $property = db_fetch_object($properties) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nproperty = (object) node_load($property->nid);
    $need_update = FALSE;
    
    foreach($nproperty->field_domain2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    foreach($nproperty->field_range2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nproperty);
    }
  } // check for properties
  
  // remove the class for evoc repository
  $term = array();
  $term['id'] = $node->title;
  $term['prefix'] = $vocabulary_title;
  evoc_remove_class($term);
}

/**
 * 
 * @param object $node
 * @param object $vocabulary_title [optional]
 * @return 
 */
function _neologism_on_deleted_property_node($node, $vocabulary_title = NULL) {
  watchdog('content', '@type: deleted %title.', array('@type' => $node->type, '%title' => $node->title));
  drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $node), '%title' => $node->title)));
  
  if( !$vocabulary_title ) {
    $vocabulary_title = db_fetch_object( db_query( db_rewrite_sql("SELECT n.title FROM {node} n WHERE n.nid = %d"), $node->field_vocabulary[0]['nid']) );
    $vocabulary_title = $vocabulary_title->title;  
  }
  
  // at this point the current property node has been removed.Now we have to check for other properties
  // that might be subPropertyOf that class.
  // check for properties
  $properties = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = '%s'"), NEOLOGISM_CT_PROPERTY); 
  while( $property = db_fetch_object($properties) ) {
    // if there exist any class that has $class as superclass change it to default superclass rdfs:Resource
    $nproperty = (object) node_load($property->nid);
    $need_update = FALSE;
    
    foreach($nproperty->field_superproperty2 as &$value) {
      if( $value['evoc_term'] == $vocabulary_title.':'.$node->title ) {
        $value['evoc_term'] = NULL;
        $need_update = TRUE;
      }
    }
    
    if( $need_update ) {
      $nclass->update_by_reference = TRUE;
      node_save($nproperty);
    }
  } 
  
   // remove the class for evoc repository
  $term = array();
  $term['id'] = $node->title;
  $term['prefix'] = $vocabulary_title;
  evoc_remove_property($term);
}

function _neologism_is_valid_id($string) {
  return ( ereg("^[a-zA-Z_]+[a-zA-Z0-9._-]*", $string, $reg) == strlen($string)); 
  //return (preg_match("/^[a-zA-Z_]+[a-zA-Z0-9._-]*/", $string) == strlen($string));
}

/**
 * This function is a wrapper function to fix the bug in rdfapi when localpart contain the prefix #
 * @param object $uri
 * @return 
 */
function neologism_rdf_uri_to_qname($uri) {
  $qname = rdf_uri_to_qname($uri);
  $qname_parts = explode(':', $qname);
  // TODO check for external vocabulary when this is missing and import it automatically
  if ( $pos = strpos($qname_parts[1], '#') !== false ) {
    $qname_parts[1] = substr($qname_parts[1], $pos);  
  } 
  return implode(':', $qname_parts);
}

/**
 * hook_evoc_widgetbehaviour_preprocess executed before a evoc_widgetbehaviour is bing shown
 * @param $field_name
 * @param $default_of_values
 * @param $extra_values
 * @return unknown_type
 */
function neologism_evoc_widgetbehaviour_preprocess($field_name, $default_of_values, $extra_values) {
	$result = array();
	
	switch ($field_name) {
		case 'field_superclass2':
			// we need to preprocess this field because at this time we have added to the list of value other super class
			// but we need to check if there is other class that might be super class of this class that is currently analyzing
			
			// in our case it is very simply just assing the extra_values to the result_list_of_values
			$result = $extra_values;
			break;
			
		case 'field_superproperty2':
			$result = $extra_values;
			break;
	}
	
	return $result;
}

/**
 * Callback to be execute after a form is built.
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
function _neologism_after_build($form, &$form_state) {
	//_neologism_fix_disabled($form['field_vocabulary']);
	_neologism_fix_disabled($form['title']);
	//print_r($form['title']);
  return $form;
}

/**
 * Find recursively the last child into a element and add the attribute disabled for such element to disable it.
 * @param $elements
 * @return unknown_type
 */
function _neologism_fix_disabled(&$elements) {
  foreach (element_children($elements) as $key) {
    if (isset($elements[$key]) && $elements[$key]) {

      // Recurse through all children elements.
      _neologism_fix_disabled($elements[$key]);
    }
  }

  if (!isset($elements['#attributes'])) {
    $elements['#attributes'] = array();
  }
  
  $elements['#attributes']['disabled'] = 'disabled';
}

/**
 * Compare the string hold by array the arrays $a['id] and $b['id'] using the strcmp function.
 * This function is the cmp_function used by "bool usort ( array &$array , callback $cmp_function )" function to
 * sort and array.
 * This functio return an integer less than, equal to, or greater than zero if the first argument is considered to be 
 * respectively less than, equal to, or greater than the second.
 * @param $a array
 * @param $b array
 * @return int
 */
function _neologism_cmp_2array_alphabetically($a, $b)
{
	return strcmp($a['id'], $b['id']);
}

/**
 * 
 * @param $value
 * @return unknown_type
 */
function _neologism_is_xsd_datatype( $value ) {
  $xsd_datatypes = neologism_get_xsd_datatype_list();
  foreach ( array_values($xsd_datatypes) as $group ) {
  	if( isset($group[$value]) ) {
  		return TRUE;
  	}	
  }
  
  return FALSE;
}

/**
 * Returns the namespace URI for a given vocabulary node, taking into
 * account the base URI of the site and the possibility of custom
 * namespaces.
 *
 * param $node object
 *   A node of content type neo_vocabulary
 * return string
 *   The full namespace URI of the vocabulary, including trailing hash
 */
function _neologism_get_namespace_uri($node) {
  $custom = $node->field_custom_namespace[0]['value'];
  if ($custom) return $custom;
  return url($node->path, array('absolute' => TRUE)) . '#';
}

/**
 * Overwritten the hook_menu_link_alter to hidden the Classes and Properties creation from navigation menu.
 * @param $item
 * @param $menu
 * @return unknown_type
 */
function neologism_menu_link_alter(&$item, $menu) {
	switch( $item['link_path'] ) {
		case 'node/add/neo-class':
		case 'node/add/neo-property':
			$item['hidden'] = 1;
			break;	
	}
}

/**
 * 
 * @return unknown_type
 */
function neologism_get_xsd_datatype_list() {
	$neologism_xsd_datatypes = array(
			t('Standard datatypes') => array(
				'rdfs:Literal' => 'rdfs:Literal',
				'xsd:string' => 'xsd:string',
				'xsd:decimal' => 'xsd:decimal',
				'xsd:integer' => 'xsd:integer',
				'xsd:date' => 'xsd:date',
				'xsd:dateTime' => 'xsd:dateTime',
				'xsd:boolean' => 'xsd:boolean',
				'rdf:XMLLiteral' => 'rdf:XMLLiteral'	
			),
			t('Date and time') => array(
				'xsd:date' => 'xsd:date',
				'xsd:dateTime' => 'xsd:dateTime',
				'xsd:time' => 'xsd:time',
				'xsd:gYearMonth' => 'xsd:gYearMonth',
				'xsd:gYear' => 'xsd:gYear',
				'xsd:gMonthDay' => 'xsd:gMonthDay',
				'xsd:time' => 'xsd:time',
				'xsd:gDay' => 'xsd:gDay',
				'xsd:gMonth' => 'xsd:gMonth'
			),
			t('Numbers') => array(
				'xsd:decimal' => 'xsd:decimal',
				'xsd:float' => 'xsd:float',
				'xsd:double' => 'xsd:double',
				'xsd:integer' => 'xsd:integer',
				'xsd:nonPositiveInteger' => 'xsd:nonPositiveInteger',
				'xsd:negativeInteger' => 'xsd:negativeInteger',
				'xsd:long' => 'xsd:long',
				'xsd:int' => 'xsd:int',
				'xsd:short' => 'xsd:short',
				'xsd:byte' => 'xsd:byte',
				'xsd:nonNegativeInteger' => 'xsd:nonNegativeInteger',
				'xsd:unsignedLong' => 'xsd:unsignedLong',
				'xsd:unsignedInt' => 'xsd:unsignedInt',
				'xsd:unsignedShort' => 'xsd:unsignedShort',
				'xsd:unsignedByte' => 'xsd:unsignedByte',
				'xsd:unsignedInt' => 'xsd:unsignedInt'
			),
			t('Other') => array(
				'xsd:hexBinary' => 'xsd:hexBinary',
				'xsd:base64Binary' => 'xsd:base64Binary',
				'xsd:anyURI' => 'xsd:anyURI',
				'xsd:normalizedString' => 'xsd:normalizedString',
				'xsd:token' => 'xsd:token',
				'xsd:language' => 'xsd:language',
				'xsd:NMTOKEN' => 'xsd:NMTOKEN',
				'xsd:Name' => 'xsd:Name',
				'xsd:NCName' => 'xsd:NCName'
			)
	  );
	return $neologism_xsd_datatypes;
}

/**
 * A writer for RDF statements. Encapsulates RAP storage and serialisation,
 * has its own namespace management, and provides a convenient API for
 * generating RDF statements.
 */
class neologism_rdf_writer {
  var $_model;
  var $_namespaces = array();
  var $_no_namespaces = array();

  function __construct() {
    define('HIDE_ADVERTISE', true);
    require_once(RDFAPI_INCLUDE_DIR . "RdfAPI.php");
    $this->_model = ModelFactory::getDefaultModel();
  }

  /**
   * Registers a namespace mapping that will be added to the written
   * RDF file.
   *
   * @param $prefix
   *   A namespace prefix, such as 'foaf'
   * @param $uri
   *   A namespace URI, such as 'http://xmlns.com/foaf/0.1/'
   */
  function register_namespace($prefix, $uri) {
    $this->_namespaces[$prefix] = $uri;
    $this->_model->addNamespace($prefix, $uri);
  }

  function triple_literal($s, $p, $o) {
    $this->_stmt($this->_uri($s), $this->_qname($p), $this->_literal($o));
  }

  function triple_uri($s, $p, $o) {
    // RAP's N3 serialiser eagerly tries to compress every URI it
    // encounters. This is not desired for URIs like mailto: and
    // web page URLs. We assume that all namespaces which we actually
    // want are already declared, and that only declared namespaces
    // will occur in subject positions. Everything else should not
    // be compressed.
    $this->_dont_compress($o);
    $this->_stmt($this->_uri($s), $this->_qname($p), $this->_uri($o));
  }

  function triple_qname($s, $p, $o) {
    $this->_stmt($this->_uri($s), $this->_qname($p), $this->_qname($o));
  }

  function triples_qname($s, $p, $os) {
    if (empty($os)) return;
    if (!is_array($os)) {
      throw new Exception("Not an array: '$os'");
    }
    foreach ($os as $qname) {
      $this->triple_qname($s, $p, $qname);
    }
  }

  function &_uri($uri) {
    if (empty($uri)) return null;
    return new Resource($uri);
  }

  function &_qname($qname) {
    if (empty($qname)) return null;
    return $this->_uri($this->_expand_qname($qname));
  }

  function &_literal($s) {
    if (empty($s)) return null;
    return new Literal($s);
  }

  function _stmt($s, $p, $o) {
    if (empty($s) || empty($p) || empty($o)) return;
    $this->_model->add(new Statement($s, $p, $o));
  }

  function _expand_qname($qname) {
    list($prefix, $local) = explode(':', $qname);
    if (!isset($this->_namespaces[$prefix])) return null;
    return $this->_namespaces[$prefix] . $local;
  }

  /**
   * Checks if there already is a namespace declaration for this URI;
   * if not, add it to the list of uncompressible namespaces.
   */
  function _dont_compress($uri) {
    if (!preg_match('!^(.*[/#:]).*?$!', $uri, $match)) return;
    if (in_array($match[1], $this->_no_namespaces)) return;
    if (in_array($match[1], $this->_namespaces)) return;
    $this->_no_namespaces[] = $match[1];
  }

  function write_rdfxml() {
    include(RDFAPI_INCLUDE_DIR . "syntax/RdfSerializer.php");
    header("Content-Type: application/rdf+xml; charset=utf-8");
    $ser = new RDFSerializer();
    echo $ser->serialize($this->_model);
  }

  function write_n3() {
    include_once(RDFAPI_INCLUDE_DIR . "syntax/N3Serializer.php");
    header("Content-Type: text/rdf+n3; charset=utf-8");
    $ser = new N3Serializer();
    $ser->setPrettyPrint(true);
    foreach ($this->_no_namespaces as $uri) {
      $ser->addNoNSPrefix($uri);
    }
    echo $ser->serialize($this->_model);
  }
}
