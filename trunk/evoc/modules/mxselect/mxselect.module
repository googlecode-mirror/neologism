<?php
// $Id: mxselect.module,v 1.7.2.10 2009/08/11 17:27:49 guidocecilio Exp $

/**
 * @file
 * Allows users to select multiple items in an easier way than the normal node-reference widget.
 */


/**
 * Implementation of hook_help().
 */
function mxselect_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/help#mxselect':
      $output = '<p>'. t('Provides a CCK widget for editing evocreference fields that allows users to select from a list of options in a left box and have them visually moved into the right box when options are chosen.') .'</p>';
      break;
  }
  return $output;
}

/**
 * Implementation of hook_form_alter().
 */
function mxselect_form_alter(&$form, $form_state, $form_id) {
  // Provide additional help for the field settings form.
  if ($form_id == 'content_field_edit_form' && isset($form['widget'])) {
    $widget_type = $form['#field']['widget']['type'];
    $field_type = $form['#field']['type'];
    $label = $form['#field']['widget']['label'];

    $output = '<p>'. t('Create a list of options as a list in <strong>Allowed values list</strong> or as an array in PHP code. These values will be the same for %field in all content types.', array('%field' => $label)) .'</p>';

    if (in_array($widget_type, array('mxselect_select'))) {
      $form['field']['multiple']['#default_value'] = 1; // Default to the selection of "Unlimited" "Number of values".

      /*
      if (in_array($field_type, array('text', 'number_integer', 'number_float', 'number_decimal'))) {
        $form['field']['allowed_values_fieldset']['#collapsed'] = FALSE;
        $form['field']['allowed_values_fieldset']['#description'] = $output;

        // If no 'allowed values' were set yet, add a remainder in the messages area.
        if (empty($form_state['post']) && empty($form['field']['allowed_values_fieldset']['allowed_values']['#default_value']) && empty($form['field']['allowed_values_fieldset']['advanced_options']['allowed_values_php']['#default_value'])) {
          drupal_set_message(t("You need to specify the 'allowed values' for this field."), 'warning');
        }
      }
      */
    }
  }
}

/**
 * Implementation of hook_widget_info().
 * This specifies the label and that it is a widget for the different field types.
 */
function mxselect_widget_info() {
  return array(
    'mxselect_select' => array(
      'label' => t('MXselect'),
      'field types' => array('evocreference'),
      'multiple values' => CONTENT_HANDLE_MODULE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 */
function mxselect_elements() {
  return array(
    'mxselect_select' => array(
      '#input' => TRUE,
      //'#columns' => array('uid'), '#delta' => 0,
      '#columns' => array('name'), '#delta' => 0,
      '#process' => array('mxselect_select_process'),
    ),
  );
}
 
/**
 * Implementation of hook_widget().
 *
 * hook_widget is a CCK hook
 *
 * Attach a single form element to the form. It will be built out and
 * validated in the callback(s) listed in hook_elements. We build it
 * out in the callbacks rather than here in hook_widget so it can be
 * plugged into any module that can provide it with valid
 * $field information.
 *
 * Content module will set the weight, field name and delta values
 * for each form element. This is a change from earlier CCK versions
 * where the widget managed its own multiple values.
 *
 * If there are multiple values for this field, the content module will
 * call this function as many times as needed.
 *
 * @param $form
 *   the entire form array, $form['#node'] holds node information
 * @param $form_state
 *   the form_state, $form_state['values'] holds the form values.
 * @param $field
 *   the field array
 * @param $delta
 *   the order of this item in the array of subelements (0, 1, 2, etc)
 *
 * @return
 *   the form item for a single element for this field
 */
function mxselect_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  switch ($field['widget']['type']) {
    case 'mxselect_select':
      $element = array(
        '#type' => 'mxselect_select',
        '#default_value' => $items,
        //'#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
        '#value_callback' => 'mxselect_value',
      );
      break;
  }
  return $element;
}

/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 * The $fields array is in $form['#field_info'][$element['#field_name']].
 */
function mxselect_select_process($element, $edit, $form_state, $form) {
  // Insert Javascript and CSS for this widget.
  $path = drupal_get_path('module', 'mxselect');
  drupal_add_js($path .'/multiselect.js');
  drupal_add_css($path .'/multiselect.css', 'module', 'all', FALSE); //doesn't aggregate: as it's not used much(?)

  $field_name = $element['#field_name'];
  $field = $form['#field_info'][$field_name];
  $field_key  = $element['#columns'][0];

  // See if this element is in the database format or the transformed format,
  // and transform it if necessary.
  if (is_array($element['#value']) && !array_key_exists($field_key, $element['#value'])) {
    $element['#value'] = optionwidgets_data2form($element, $element['#default_value'], $field);
  }

  // Get a list of all options for this field.
  $options = optionwidgets_options($field);
  
  // TODO Try to do a better solution to work directly with evoc index
  // This a patch because MXselect use numeric index and evoc save the fields with string index (curies) 
  if( isset($element['#value'][$field_key][0]) && !is_numeric($element['#value'][$field_key][0]) ) {
    foreach( $element['#value'][$field_key] as &$value ) {
      for( $i = 0; $i < count($options); $i++ ) {
        if( $options[$i] == $value ) {
          $value = $i;
          break;
        }
      }
    }
    unset($value);
  }

  // Create some arrays for use later in the function.
  $unselected_options = array();
  $selected_options = array();

  // Add selected items to the array first
  if (is_array($element['#value'][$field_key])) {
    foreach ($element['#value'][$field_key] as $key => $value) {
      if (isset($options[$value])) {
        $selected_options[$value] = $options[$value];
      }
    }
  }
  // Add the remaining options to the arrays
  foreach ($options as $key => $value) {
    if (!isset($selected_options[$key])) {
      $unselected_options[$key] = $value;
    }
  }

  // Set up useful variables.
  $addbutton = $element['#field_name'] ."_add";
  $removebutton = $element['#field_name'] ."_remove";
  $selfield = $element['#field_name'] ."_sel";
  $unselfield = $element['#field_name'] ."_unsel";

  // Call methods to create prefix. (ie the non-selected table, etc)
  $prefix_pre = '<div class="form-item"><label for="edit-title">'. t($element['#title']) .':';
  if ($field['required']) {
    $prefix_pre .= '<span class="form-required" title="'. t('This field is required.') .'"> * </span>';
  }
  $prefix_pre .= "</label>\n";

  $prefix_pre .= "<div id=\"multiselect_labels\"><div id=\"label_unselected\">". t('Available Options') .":</div>\n";
  $prefix_pre .= "<div id=\"label_selected\">". t('Selected Options') .":</div>\n</div>\n";
  $prefix_pre .= "<div id=\"multiselect_available\">";
  $prefix_pre .= _mxselect_html_for_unselected_box_start($unselfield, $element['#field_name']);
  $prefix_options = _mxselect_html_for_unselected_box_options($unselected_options);
  $prefix_post = "</select>\n</div>\n";
  $prefix_post .= _mxselect_html_for_buttons($element['#field_name']);

  $element[$field_key] = array(
    '#type' => 'select',
    //'#title' => $element['#title'], // Title is added in the prefix section. If added here, displays incorrectly.
    '#description' => $element['#description'],
    '#required' => isset($element['#required']) ? $element['#required'] : $field['required'],
    '#multiple' => isset($element['#multiple']) ? $element['#multiple'] : $field['multiple'],
    '#options' => $selected_options,
    '#size' => 10,
    '#prefix' => $prefix_pre . $prefix_options . $prefix_post,
    '#suffix' => "\n</div>\n",
    '#attributes' => array('class' => "$selfield multiselect_sel", 'id' => $element['#field_name']),
    '#default_value' => isset($element['#value'][$field_key]) ? $element['#value'][$field_key] : NULL,
    
    // these properties are added to keep compatibilities with evocreference field
    '#field_name' => $element['#field_name'],
    '#type_name' => $element['#type_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
  );

  // Set #element_validate in a way that it will not wipe out other
  // validation functions already set by other modules.
  
  /*
  if (empty($element['#element_validate'])) {
    $element['#element_validate'] = array();
  }
  array_unshift($element['#element_validate'], 'optionwidgets_validate');
  */
 
  if (empty($element['#element_validate'])) {
    $element['#element_validate'] = array();
  }
  array_unshift($element['#element_validate'], 'mxselectwidgets_validate');

  return $element;
}

/**
 * Implementation of hook_theme().
 */
function mxselect_theme() {
  return array(
    'mxselect_select' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * FAPI theme for an individual elements.
 *
 * The textfield or select is already rendered by the
 * textfield or select themes and the html output
 * lives in $element['#children']. Override this theme to
 * make custom changes to the output.
 *
 * $element['#field_name'] contains the field name
 * $element['#delta]  is the position of this element in the group
 */
function theme_mxselect_select($element) {
  return $element['#children'];
}

/**
 * Provides html to draw the "not selected" box
 */
function _mxselect_html_for_unselected_box_start($unselfield, $fieldname) {
  $boxhtml = '';
  $boxhtml .= "<select name=\"". $unselfield ."\" multiple=\"multiple\" class=\"form-select ". $unselfield ." multiselect_unsel\" id=\"". $fieldname ."\" size=\"10\">\n";
  return $boxhtml;
}

function _mxselect_html_for_unselected_box_options($unselected_options) {
  $boxhtml = '';
  foreach ($unselected_options as $value => $name) {
    $boxhtml .= "<option value=\"". $value ."\">". $name ."</option>\n";
  }
  return $boxhtml;
}

/**
 * Provides html to display the buttons on the form.
 * 
 * @param object $fieldname
 * @return 
 */
function _mxselect_html_for_buttons($fieldname) {
  $buttons_code = "<ul id=\"multiselect_btns\">
<li class=\"multiselect_add\" id=\"". $fieldname ."\"><a href=\"javascript:;\">Add</a></li>
<li class=\"multiselect_remove\" id=\"". $fieldname ."\"><a href=\"javascript:;\">Remove</a></li>
</ul>";
  return $buttons_code;
}

/**
 * Value for a nodereference autocomplete element.
 *
 * Substitute in the node title for the node nid.
 */

function mxselect_value($element, $edit = FALSE) {
  //$field_key  = $element['#columns'][0];
  //if (!empty($element['#default_value'][$field_key])) {
    //$nid = $element['#default_value'][$field_key];
    //$element[$field_key]['#options'];
    //$value = db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $nid));
    //$value .= ' [nid:'. $nid .']';
    //return array($field_key => $value);
    //return array($field_key => $nid);
  //}
  //return array($field_key => NULL);
}


/**
 * Validate the value of superclass2 field and convert/normalise value to evoc_term format
 * 
 * @param object $element
 * @param object $form_state
 * @return 
 */
function mxselectwidgets_validate($element, &$form_state) {
  $field_key = $element['#columns'][0];
  
  $term = array();
  foreach ($element['evoc_term']['#options'] as $value) {
     $term[] = array($field_key => $value);
  }
  
  form_set_value($element, $term, $form_state);
}
